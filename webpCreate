#!/usr/bin/env zsh
# webpCreate version: 1.12.3-beta
setopt null_glob

# …rest of script…


# ─── Help & Description ──────────────────────────────────────────────────────────
show_help() {
  cat <<-EOF
webpCreate: batch-convert images to WebP with concise progress and stats.
Usage:
  webpCreate [options] [dir1 dir2 ...] [file1 file2 ...]
  If no directories or files are given, defaults to the current directory.

Options:
  -h, --help            Show this help and exit
  -q, --quality Q       Set cwebp quality (0–100; default 80)
  --maxd N              Resize longest side to ≤ N px (skips prompt)
  --lossless            Use cwebp -lossless
  --mt, --multithread   Enable cwebp -mt (multi‐threaded)
  --cwoption OPT        Pass arbitrary OPT (e.g. "-af") to cwebp
  --parallel, -P        Process multiple directories in parallel
  --jpeg                Also create JPEG copies with same dimensions/quality
  -o, --orientation     Orientation handling: detect (default), warn, ignore
  --no-meta             Skip embedding comment metadata
  --dryrun, --dry-run   Preview results without converting (verbose mode)
  --debug               Show debugging info and math calculations

Examples:
  webpCreate .  
  webpCreate -q 75 --maxd 1200 ~/Pictures ~/Downloads  
  webpCreate --parallel --lossless --mt dirA dirB  
  webpCreate --jpeg -q 85 --maxd 1600 ~/Photos  
  webpCreate -o warn --jpeg ~/Photos  
  webpCreate -o ignore ~/TrustedImages
  webpCreate --dryrun --debug ~/Photos/photo1.jpg ~/Photos/photo2.png
  webpCreate --debug file1.jpg file2.png
EOF
}

# ─── Flag Parsing ───────────────────────────────────────────────────────────────
cwebp_opts=(-quiet)   # start with -quiet to suppress verbose cwebp output
do_parallel=false
create_jpeg=false
orientation_mode="detect"  # default: detect, warn, ignore
dry_run=false
debug_mode=false
embed_meta=true
dirs=()
files=()
quality=""
maxd_flag=""

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help) show_help; exit 0;;
    -q|--quality)       shift; quality=$1; cwebp_opts+=(-q $quality); shift;;
    --maxd)             shift; maxDim=$1; do_resize=true; maxd_flag="yes"; shift;;
    --lossless)         cwebp_opts+=(-lossless); shift;;
    --mt|--multithread) cwebp_opts+=(-mt); shift;;
    --cwoption)         shift; cwebp_opts+=("$1"); shift;;
    --parallel|-P)      do_parallel=true; shift;;
    --jpeg)             create_jpeg=true; shift;;
    -o|--orientation)   shift; orientation_mode=$1; shift;;
    --no-meta)          embed_meta=false; shift;;
    --dryrun|--dry-run) dry_run=true; shift;;
    --debug)            debug_mode=true; shift;;
    --) shift; break;;
    -*) echo "Unknown option: $1"; exit 1;;
    *) 
      if [[ -f "$1" ]]; then
        files+=("$1")
      elif [[ -d "$1" ]]; then
        dirs+=("$1")
      else
        echo "❌ '$1' is not a valid file or directory"; exit 1
      fi
      shift;;
  esac
done

# Set default directory if no dirs or files specified
if (( ${#dirs[@]} == 0 && ${#files[@]} == 0 )); then
  dirs=(".")
fi

# Enable debug output if debug mode
if [[ $debug_mode == true ]]; then
  echo "🐛 Debug mode enabled"
  echo "🐛 Directories: ${dirs[@]:-none}"
  echo "🐛 Files: ${files[@]:-none}"
  echo "🐛 Quality: ${quality:-80}"
  echo "🐛 Max dimension: ${maxDim:-none}"
  echo "🐛 Orientation mode: $orientation_mode"
  echo "🐛 Dry run: $dry_run"
  echo "🐛 Embed metadata comment: $embed_meta"
fi

# Validate orientation mode
case "$orientation_mode" in
  detect|warn|ignore) ;;
  *) echo "❌ Invalid orientation mode: $orientation_mode. Use: detect, warn, or ignore"; exit 1;;
esac

# ─── Resize Prompt ─────────────────────────────────────────────────────────────
if [[ -z $maxd_flag ]]; then
  read -q "?Would you like to resize images so their longest side is capped? [y/N] " resize_choice
  echo
  if [[ $resize_choice =~ ^[Yy]$ ]]; then
    read -r "?Enter max dimension (pixels) for longest side (e.g. 1200): " maxDim
    [[ "$maxDim" =~ ^[0-9]+$ ]] || { echo "❌ Invalid number: $maxDim"; exit 1; }
    do_resize=true
  else
    do_resize=false
  fi
else
  do_resize=true
fi

# ─── Dependency Checks ──────────────────────────────────────────────────────────
required_cmds=(cwebp sips)
if [[ $embed_meta == true ]]; then
  required_cmds+=(exiftool)
fi
for cmd in "${required_cmds[@]}"; do
  if ! command -v $cmd &>/dev/null; then
    brew_cmd=${cmd==cwebp?webp:imagemagick}
    if [[ $cmd == exiftool ]]; then brew_cmd=exiftool; fi
    echo "❌ Missing '$cmd'. Install with: brew install $brew_cmd"
    echo "   Or run installer: bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)"
    exit 1
  fi
done

# ─── Utilities ─────────────────────────────────────────────────────────────────
human_size(){
  local b=${1:-0}
  local mb=$((b/1024/1024))
  local frac=$(((b/1024)%1024*100/1024))
  printf "%d.%02d MB" $mb $frac
}

# Enhanced orientation detection using multiple metadata sources
detect_orientation(){
  local file=$1
  local exif_orient mdls_orient rotation_tag exiftool_orient exiftool_rotation
  
  if [[ $debug_mode == true ]]; then
    echo "🐛   Checking orientation metadata for: $(basename "$file")"
  fi
  
  # Try EXIF orientation first (most reliable)
  exif_orient=$(sips -g orientation "$file" 2>/dev/null | awk '/orientation/ {print $2}')
  if [[ $debug_mode == true ]]; then
    echo "🐛   sips orientation: $exif_orient"
  fi
  
  if [[ "$exif_orient" != "<nil>" && "$exif_orient" != "" && "$exif_orient" != "0" ]]; then
    echo "$exif_orient"
    return
  fi
  
  # Try macOS metadata (kMDItemOrientation)
  mdls_orient=$(mdls "$file" 2>/dev/null | grep -i "kMDItemOrientation" | awk '{print $NF}')
  if [[ $debug_mode == true ]]; then
    echo "🐛   kMDItemOrientation: $mdls_orient"
  fi
  if [[ "$mdls_orient" != "" && "$mdls_orient" != "(null)" && "$mdls_orient" != "0" ]]; then
    echo "$mdls_orient"
    return
  fi
  
  # Check for macOS Rotation tag (used by Finder)
  rotation_tag=$(mdls "$file" 2>/dev/null | grep -i "rotation" | awk '{print $NF}')
  if [[ $debug_mode == true ]]; then
    echo "🐛   Rotation tag: $rotation_tag"
  fi
  if [[ "$rotation_tag" != "" && "$rotation_tag" != "(null)" && "$rotation_tag" != "0" ]]; then
    echo "$rotation_tag"
    return
  fi
  
  # Try exiftool for more comprehensive EXIF/rotation data
  if command -v exiftool >/dev/null 2>&1; then
    exiftool_orient=$(exiftool -s -s -s -Orientation -n "$file" 2>/dev/null)
    if [[ $debug_mode == true ]]; then
      echo "🐛   exiftool orientation: $exiftool_orient"
    fi
    if [[ -n "$exiftool_orient" && "$exiftool_orient" != "0" ]]; then
      echo "$exiftool_orient"
      return
    fi

    exiftool_rotation=$(exiftool -s -s -s -Rotation -n "$file" 2>/dev/null)
    if [[ $debug_mode == true ]]; then
      echo "🐛   exiftool rotation: $exiftool_rotation"
    fi
    if [[ -n "$exiftool_rotation" && "$exiftool_rotation" != "0" ]]; then
      echo "$exiftool_rotation"
      return
    fi
  fi
  
  if [[ $debug_mode == true ]]; then
    echo "🐛   No orientation metadata found"
  fi
  # No orientation metadata found
  echo "<nil>"
}

ask_conflict(){
  local file=$1 choice
  while true; do
    echo "⚠️  WEBP/$file exists. (o)verwrite / (i)ncrement / (s)kip?"
    read -sk1 choice; echo
    case $choice in
      [oO]) return 0;;
      [iI]) return 1;;
      [sS]) return 2;;
      *) echo "❓ Press o, i, or s.";;
    esac
  done
}

# ─── Convert + Conflict Handler ─────────────────────────────────────────────────
convert_and_handle_conflict(){
  local input=$1 base out newW newH w h suffix temp_input orientation rotate_degrees rotated jpeg_out
  base=${input%.*}
  suffix=$([ "$do_resize" = true ] && echo "-$maxDim" || echo "")
  out="${base}${suffix}.webp"
  temp_input="$input"

  # Compute resize dimensions if needed
  if $do_resize; then
    w=$(sips -g pixelWidth "$input" 2>/dev/null | awk '/pixelWidth/  {print $2}')
    h=$(sips -g pixelHeight "$input" 2>/dev/null | awk '/pixelHeight/ {print $2}')
    if (( w >= h )); then newW=$maxDim; newH=0; else newW=0; newH=$maxDim; fi
  fi

  # Debug output
  if [[ $debug_mode == true ]]; then
    echo "🐛 Processing: $input"
    echo "🐛   Original dimensions: ${w:-unknown}×${h:-unknown}"
    echo "🐛   Resize dimensions: ${newW:-original}×${newH:-original}"
    echo "🐛   Orientation mode: $orientation_mode"
    local detected_orient=$(detect_orientation "$input")
    echo "🐛   Detected orientation: $detected_orient"
  fi

  # Dry run mode - just show what would be done
  if [[ $dry_run == true ]]; then
    local in_size out_size_est
    in_size=$(stat -f%z "$input" 2>/dev/null)
    # Rough estimate: WebP is typically 25-30% of original size
    out_size_est=$(( ${in_size:-0} * 30 / 100 ))
    
    echo "🔍 WOULD PROCESS: $input"
    echo "   → Output: WEBP/$out"
    echo "   → Size estimate: $(human_size ${in_size:-0}) → $(human_size $out_size_est)"
    if [[ $create_jpeg == true ]]; then
      echo "   → Also create: JPG/${base}${suffix}.jpg"
    fi
    return 0
  fi

  # Create temporary image with orientation handling based on user preference
  temp_input="${base}_temp.jpg"
  
  case $orientation_mode in
    "ignore")
      # TRULY preserve original file data - bypass all temp file processing
      # Skip temp_input entirely and use original file directly with cwebp
      if [[ $debug_mode == true ]]; then
        echo "🐛   IGNORE mode: Bypassing all orientation processing"
      fi
      
      # Use original file directly - no temp file, no processing
      temp_input="$input"
      ;;
      
    "warn")
      # Detect orientation issues and warn user, but don't auto-fix
      detected_orient=$(detect_orientation "$input")
      
      # Check for potential orientation mismatch
      if [[ "$detected_orient" == "<nil>" ]] && (( (w > h && w > 2000) || (h > w && h > 2000) )); then
        echo "⚠️  Warning: $input has no orientation metadata"
        echo "   File dimensions: ${w}×${h}, Preview may auto-rotate for display"
        echo "   WebP output may not match Preview appearance"
      fi
      
      # Process without orientation correction
      if $do_resize; then
        sips -Z $maxDim "$input" --out "$temp_input" >/dev/null 2>&1
      else
        cp "$input" "$temp_input"
      fi
      ;;
      
    "detect")
      # Enhanced orientation detection - check EXIF first, then macOS metadata as fallback
      detected_orient=$(detect_orientation "$input")
      
      if [[ $debug_mode == true ]]; then
        echo "🐛   DETECT mode: Found orientation metadata: $detected_orient"
      fi
      
      # Check EXIF orientation first
      if [[ "$detected_orient" != "<nil>" && "$detected_orient" != "" && "$detected_orient" != "1" && "$detected_orient" != "0" ]]; then
        if [[ $debug_mode == true ]]; then
          echo "🐛   Applying EXIF orientation correction"
        fi
        # EXIF orientation found - let sips apply it
        if $do_resize; then
          sips -Z $maxDim "$input" --out "$temp_input" >/dev/null 2>&1
        else
          sips -s format jpeg -s formatOptions 100 "$input" --out "$temp_input" >/dev/null 2>&1
        fi
        # Reset orientation flag since transformation has been applied  
        sips -s orientation 1 "$temp_input" >/dev/null 2>&1
      else
        # No EXIF orientation - check macOS metadata as fallback
        mdls_orient=$(mdls "$input" 2>/dev/null | grep -i "kMDItemOrientation" | awk '{print $NF}')
        
        if [[ "$mdls_orient" != "" && "$mdls_orient" != "(null)" && "$mdls_orient" != "0" ]]; then
          if [[ $debug_mode == true ]]; then
            echo "🐛   Applying macOS metadata orientation (kMDItemOrientation: $mdls_orient)"
          fi
          # macOS has display orientation info - apply it
          if $do_resize; then
            sips -Z $maxDim "$input" --out "$temp_input" >/dev/null 2>&1
          else
            sips -s format jpeg -s formatOptions 100 "$input" --out "$temp_input" >/dev/null 2>&1
          fi
        else
          if [[ $debug_mode == true ]]; then
            echo "🐛   No orientation metadata found - preserving as-is"
          fi
          # No metadata at all - preserve as-is
          if $do_resize; then
            sips -Z $maxDim "$input" --out "$temp_input" >/dev/null 2>&1
          else
            cp "$input" "$temp_input"
          fi
        fi
      fi
      ;;
  esac

  # Map orientation codes to rotation degrees and fix pixels/dimensions
  orientation=$(detect_orientation "$temp_input")
  case "$orientation" in
    6) rotate_degrees=90 ;;
    3) rotate_degrees=180 ;;
    8) rotate_degrees=270 ;;
    *) rotate_degrees=0 ;;
  esac

  if (( rotate_degrees != 0 )); then
    rotated="${base}_rot.jpg"
    sips -r $rotate_degrees "$temp_input" --out "$rotated" >/dev/null 2>&1
    sips -s orientation 1 "$rotated" >/dev/null 2>&1
    if [[ "$temp_input" != "$input" ]]; then
      rm -f "$temp_input"
    fi
    temp_input="$rotated"
    if $do_resize && (( rotate_degrees == 90 || rotate_degrees == 270 )); then
      local tmp=$newW
      newW=$newH
      newH=$tmp
    fi
  fi

  mkdir -p WEBP
  if [[ -e WEBP/$out ]]; then
    ask_conflict "$out"
    action=$?
    if (( action == 0 )); then
      :  # overwrite
    elif (( action == 1 )); then
      local n=1
      while [[ -e WEBP/${base}${suffix}_$n.webp ]]; do ((n++)); done
      out="${base}${suffix}_$n.webp"
    else
      rm -f "$temp_input"
      return 1
    fi
  fi

  # Run cwebp with appropriate options based on mode
  if [[ $orientation_mode == "ignore" ]]; then
    # In ignore mode, disable EXIF orientation processing entirely
    if [[ $debug_mode == true ]]; then
      echo "🐛   IGNORE mode: Disabling EXIF orientation in cwebp"
    fi
    
    if $do_resize; then
      # Use cwebp's resize with metadata stripping
      cwebp "${cwebp_opts[@]}" -resize $maxDim 0 -metadata none "$temp_input" -o "WEBP/$out"
    else
      # Strip all metadata to ignore orientation
      cwebp "${cwebp_opts[@]}" -metadata none "$temp_input" -o "WEBP/$out"
    fi
  else
    # Normal processing through temp file
    cwebp "${cwebp_opts[@]}" "$temp_input" -o "WEBP/$out"
  fi

  if [[ $embed_meta == true ]]; then
    exiftool -overwrite_original -Comment='Created with webpCreate (chachwick.com – github.com/chachwick/webpCreate)' "WEBP/$out" >/dev/null 2>&1
  fi

  # Create JPEG copy if requested
  if $create_jpeg; then
    local jpeg_out="${base}${suffix}.jpg"
    local jpeg_quality=${quality:-80}
    
    mkdir -p JPG
    
    # Handle JPEG filename conflicts
    if [[ -e JPG/$jpeg_out ]]; then
      ask_conflict "$jpeg_out"
      local jpeg_action=$?
      if (( jpeg_action == 0 )); then
        :  # overwrite
      elif (( jpeg_action == 1 )); then
        local n=1
        while [[ -e JPG/${base}${suffix}_$n.jpg ]]; do ((n++)); done
        jpeg_out="${base}${suffix}_$n.jpg"
      fi
      
      if (( jpeg_action != 2 )); then  # not skip
        # Create JPEG - handle ignore mode specially
        if [[ $orientation_mode == "ignore" ]]; then
          # Use cwebp to create JPEG to avoid sips orientation processing
          if $do_resize; then
            cwebp -jpeg_quality $jpeg_quality -resize $maxDim 0 "$input" -o "JPG/$jpeg_out" 2>/dev/null || \
            sips -s formatOptions $jpeg_quality "$temp_input" --out "JPG/$jpeg_out" >/dev/null 2>&1
          else
            # For no resize in ignore mode, convert directly
            sips -s format jpeg -s formatOptions $jpeg_quality "$input" --out "JPG/$jpeg_out" >/dev/null 2>&1
          fi
        else
          # Normal JPEG creation through temp file
          sips -s formatOptions $jpeg_quality "$temp_input" --out "JPG/$jpeg_out" >/dev/null 2>&1
        fi
      fi
    else
      # Create JPEG - handle ignore mode specially
      if [[ $orientation_mode == "ignore" ]]; then
        # Use original file to avoid orientation processing
        if $do_resize; then
          cwebp -jpeg_quality $jpeg_quality -resize $maxDim 0 "$input" -o "JPG/$jpeg_out" 2>/dev/null || \
          sips -s formatOptions $jpeg_quality "$temp_input" --out "JPG/$jpeg_out" >/dev/null 2>&1
        else
          # For no resize in ignore mode, convert directly
          sips -s format jpeg -s formatOptions $jpeg_quality "$input" --out "JPG/$jpeg_out" >/dev/null 2>&1
        fi
      else
        # Normal JPEG creation through temp file
        sips -s formatOptions $jpeg_quality "$temp_input" --out "JPG/$jpeg_out" >/dev/null 2>&1
      fi
    fi
  fi

  if [[ $embed_meta == true && $create_jpeg == true && -f "JPG/$jpeg_out" ]]; then
    exiftool -overwrite_original -Comment='Created with webpCreate (chachwick.com – github.com/chachwick/webpCreate)' "JPG/$jpeg_out" >/dev/null 2>&1
  fi

  # Clean up temp file (but not if it's the original in ignore mode)
  if [[ "$temp_input" != "$input" ]]; then
    rm -f "$temp_input"
  fi
  # Print concise info: filename, before→after sizes
  local in_size out_size
  in_size=$(stat -f%z "$input" 2>/dev/null)
  out_size=$(stat -f%z "WEBP/$out" 2>/dev/null)
  printf "▶ %s: %s → %s\n" \
    "$input" "$(human_size ${in_size:-0})" "$(human_size ${out_size:-0})"

  return 0
}

# ─── Directory Processing ────────────────────────────────────────────────────────
process_directory(){
  local dir=$1 f size orig_size=0 webp_size=0 count=0
  echo "── Processing: $dir ─────────────────────────────────────────"
  cd "$dir" || { echo "❌ Cannot cd into $dir"; return; }

  # Ghost-file check
  local ghosts=()
  for f in *.jpg(N) *.jpeg(N) *.png(N) *.JPG(N) *.JPEG(N) *.PNG(N); do
    [[ -e $f && ! -s $f ]] && ghosts+=("$f")
  done
  if (( ${#ghosts[@]} )); then
    echo "⚠️  ${#ghosts[@]} ghost files detected:"
    printf ' - %s\n' "${ghosts[@]}"
    read -q "?Proceed with downloaded files only? [y/N] " c; echo
    [[ $c != [yY] ]] && { echo "Skipping $dir"; cd - &>/dev/null; return; }
  fi

  # HEIC → JPEG
  local heics=( *.heic(N) *.HEIC(N) )
  if (( ${#heics[@]} )); then
    if [[ $dry_run == true ]]; then
      echo "🔍 WOULD CONVERT ${#heics[@]} HEIC files to JPEG and move to HEIC/"
    else
      mkdir -p HEIC
      for f in "${heics[@]}"; do
        sips -s format jpeg "$f" --out "${f%.*}.jpg"
        mv "$f" HEIC/
      done
    fi
  fi


  # Convert JPG/JPEG only if present
  local jpgs=( *.jpg(N) *.JPG(N) *.jpeg(N) *.JPEG(N) )
  if (( ${#jpgs[@]} )); then
    if [[ $dry_run != true ]]; then
      mkdir -p JPG
    fi
    for f in "${jpgs[@]}"; do
      [[ -f $f ]] || continue
      (( count++ ))
      file_size=$(stat -f%z "$f" 2>/dev/null)
      orig_size=$(( orig_size + ${file_size:-0} ))
      if convert_and_handle_conflict "$f"; then
        if [[ $dry_run != true ]]; then
          mv "$f" JPG/
        fi
      fi
    done
  fi

  # Convert PNG only if present
  local pngs=( *.png(N) *.PNG(N) )
  if (( ${#pngs[@]} )); then
    if [[ $dry_run != true ]]; then
      mkdir -p PNG
    fi
    for f in "${pngs[@]}"; do
      [[ -f $f ]] || continue
      (( count++ ))
      file_size=$(stat -f%z "$f" 2>/dev/null)
      orig_size=$(( orig_size + ${file_size:-0} ))
      if convert_and_handle_conflict "$f"; then
        if [[ $dry_run != true ]]; then
          mv "$f" PNG/
        fi
      fi
    done
  fi

  # Tally WEBP sizes only if WEBP folder exists
  if [[ -d WEBP ]]; then
    for w in WEBP/*.webp(N); do
      file_size=$(stat -f%z "$w" 2>/dev/null)
      webp_size=$(( webp_size + ${file_size:-0} ))
    done
  fi
  # In parallel mode, write a .stats file; otherwise collect in arrays
  if [[ -n $PARALLEL_TMPDIR ]]; then
    printf "%s|%d|%d|%d\n" "$dir" "$count" "$orig_size" "$webp_size" \
      > "$PARALLEL_TMPDIR/$(basename "$dir").stats"
  else
    SUM_COUNT[$dir]=$count
    SUM_JPG[$dir]=$orig_size
    SUM_WEBP[$dir]=$webp_size
    dirs_processed+=("$dir")
  fi

  cd - &>/dev/null
}

# ─── Declare Associative Arrays for Stats Collection ────────────────────────────
declare -A SUM_COUNT SUM_JPG SUM_WEBP
dirs_processed=()

# ─── Prepare for Parallel Stats Collection ─────────────────────────────────────
if [[ $do_parallel = true ]]; then
  PARALLEL_TMPDIR=$(mktemp -d /tmp/webpCreate.XXXX)
  echo "🛠  Parallel mode: writing per-dir stats to $PARALLEL_TMPDIR"
fi

# ─── Process Individual Files Function ────────────────────────────────────────
process_files() {
  local file count=0 orig_size=0 webp_size=0 file_size
  
  echo "── Processing individual files ──────────────────────────────"
  
  for file in "${files[@]}"; do
    [[ -f "$file" ]] || { echo "❌ File not found: $file"; continue; }
    
    # Check if it's a supported image format
    case "${file##*.}" in
      jpg|jpeg|png|JPG|JPEG|PNG) ;;
      *) echo "⚠️  Skipping unsupported file: $file"; continue ;;
    esac
    
    (( count++ ))
    file_size=$(stat -f%z "$file" 2>/dev/null)
    orig_size=$(( orig_size + ${file_size:-0} ))
    
    if convert_and_handle_conflict "$file"; then
      if [[ $dry_run != true ]]; then
        # Move to appropriate folder based on file type
        case "${file##*.}" in
          jpg|jpeg|JPG|JPEG) mkdir -p JPG; mv "$file" JPG/ 2>/dev/null || true ;;
          png|PNG) mkdir -p PNG; mv "$file" PNG/ 2>/dev/null || true ;;
        esac
      fi
    fi
  done
  
  # Calculate WebP sizes
  if [[ -d WEBP ]]; then
    for w in WEBP/*.webp(N); do
      file_size=$(stat -f%z "$w" 2>/dev/null)
      webp_size=$(( webp_size + ${file_size:-0} ))
    done
  fi
  
  # Store stats for final summary
  SUM_COUNT["individual_files"]=$count
  SUM_JPG["individual_files"]=$orig_size
  SUM_WEBP["individual_files"]=$webp_size
  dirs_processed+=("individual_files")
}

# ─── Main Loop: Files, then Directories ────────────────────────────────────────
# Process individual files first
if (( ${#files[@]} > 0 )); then
  process_files
fi

# Then process directories
if [[ $do_parallel = true ]] && (( ${#dirs[@]} > 0 )); then
  for d in "${dirs[@]}"; do
    process_directory "$d" &
  done
  wait
else
  for d in "${dirs[@]}"; do
    process_directory "$d"
  done
fi

# ─── Final Summary ─────────────────────────────────────────────────────────────
echo
echo "# Final Conversion Summary"

if [[ -n $PARALLEL_TMPDIR ]]; then
  for stats in "$PARALLEL_TMPDIR"/*.stats; do
    IFS='|' read -r dir count orig webp < "$stats"
    saved=$(( ${orig:-0} - ${webp:-0} ))
    if (( ${orig:-0} > 0 )); then
      pct=$(( (${saved:-0} * 1000 / ${orig:-1} + 5) / 10 ))
    else
      pct=0
    fi
    echo
    echo "• Directory: $dir"
    echo "   - Images processed:    $count"
    echo "   - Original total size: $(human_size $orig)"
    echo "   - WebP total size:     $(human_size $webp)"
    echo "   - Savings:             $(human_size $saved) ($pct% reduction)"
  done
  rm -rf "$PARALLEL_TMPDIR"
else
  for dir in "${dirs_processed[@]}"; do
    count=${SUM_COUNT[$dir]}
    orig=${SUM_JPG[$dir]}
    webp=${SUM_WEBP[$dir]}
    saved=$(( ${orig:-0} - ${webp:-0} ))
    if (( ${orig:-0} > 0 )); then
      pct=$(( (${saved:-0} * 1000 / ${orig:-1} + 5) / 10 ))
    else
      pct=0
    fi
    echo
    if [[ "$dir" == "individual_files" ]]; then
      echo "• Individual files processed:"
    else
      echo "• Directory: $dir"
    fi
    echo "   - Images processed:    $count"
    echo "   - Original total size: $(human_size $orig)"
    echo "   - WebP total size:     $(human_size $webp)"
    echo "   - Savings:             $(human_size $saved) ($pct% reduction)"
    
    # Debug output for final calculations
    if [[ $debug_mode == true ]]; then
      echo "🐛   Debug: orig=$orig, webp=$webp, saved=$saved, pct=$pct"
    fi
  done
fi
