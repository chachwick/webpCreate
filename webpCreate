#!/usr/bin/env zsh
setopt null_glob

# â”€â”€â”€ Help & Description â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
show_help() {
  cat <<-EOF
webpCreate: batch-convert images to WebP with concise progress and stats.

What it does:
  â€¢ Converts JPEG, PNG (caseâ€insensitive), and HEIC (via sips) to WebP  
  â€¢ Organizes originals into JPG/, PNG/, HEIC/ and outputs into WEBP/  
  â€¢ Handles name conflicts (overwrite/increment/skip)  
  â€¢ Optionally resizes longest side â‰¤ max dimension  
  â€¢ Supports quality tuning, lossless, multiâ€thread, arbitrary cwebp flags, parallel dirs  
  â€¢ Reports per-directory file counts, sizes, total savings, and percentage reduction

Usage:
  webpCreate [options] [dir1 dir2 ...]
  If no directories are given, defaults to the current directory.

Installation & Updates:
  â€¢ Initial install:
      bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)  
  â€¢ For updates:
      update-webpCreate

Options:
  -h, --help            Show this help and exit
  -q, --quality Q       Set cwebp quality (0â€“100; default 80)
  --maxd N              Resize longest side to â‰¤ N px (skips prompt)
  --lossless            Use cwebp -lossless
  --mt, --multithread   Enable cwebp -mt (multiâ€threaded)
  --cwoption OPT        Pass arbitrary OPT (e.g. "-af") to cwebp
  --parallel, -P        Process multiple directories in parallel

Examples:
  webpCreate .
  webpCreate -q 75 --maxd 1200 ~/Pictures ~/Downloads
  webpCreate --parallel --lossless --mt dirA dirB
EOF
}

# â”€â”€â”€ Flag Parsing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwebp_opts=(-quiet)   # start with -quiet to suppress verbose output
do_parallel=false
dirs=()
quality=""
maxd_flag=""

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help) show_help; exit 0;;
    -q|--quality)       shift; quality=$1; cwebp_opts+=(-q $quality); shift;;
    --maxd)             shift; maxDim=$1; do_resize=true; maxd_flag="yes"; shift;;
    --lossless)         cwebp_opts+=(-lossless); shift;;
    --mt|--multithread) cwebp_opts+=(-mt); shift;;
    --cwoption)         shift; cwebp_opts+=("$1"); shift;;
    --parallel|-P)      do_parallel=true; shift;;
    --) shift; break;;
    -*) echo "Unknown option: $1"; exit 1;;
    *) dirs+=("$1"); shift;;
  esac
done

(( ${#dirs[@]} == 0 )) && dirs=(".")

# â”€â”€â”€ Resize Prompt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [[ -z $maxd_flag ]]; then
  read -q "?Would you like to resize images so their longest side is capped? [y/N] " resize_choice
  echo
  if [[ $resize_choice =~ ^[Yy]$ ]]; then
    read -r "?Enter max dimension (pixels) for longest side (e.g. 1200): " maxDim
    [[ "$maxDim" =~ ^[0-9]+$ ]] || { echo "âŒ Invalid number: $maxDim"; exit 1; }
    do_resize=true
  else
    do_resize=false
  fi
else
  do_resize=true
fi

# â”€â”€â”€ Dependency Checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for cmd in cwebp sips; do
  if ! command -v $cmd &>/dev/null; then
    brew_cmd=${cmd==cwebp?webp:imagemagick}
    echo "âŒ Missing '$cmd'. Install with: brew install $brew_cmd"
    echo "   Or run installer: bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)"
    exit 1
  fi
done

# â”€â”€â”€ Summary Data Containers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
typeset -Ag SUM_JPG SUM_PNG SUM_WEBP SUM_COUNT
dirs_processed=()

# â”€â”€â”€ Utilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
human_size(){
  local b=$1
  printf "%d.%02d MB" $((b/1024/1024)) $(((b/1024)%1024*100/1024))
}

ask_conflict(){
  local file=$1 choice
  while true; do
    echo "âš ï¸  WEBP/$file exists. (o)verwrite / (i)ncrement / (s)kip?"
    read -sk1 choice; echo
    case $choice in
      [oO]) return 0;;
      [iI]) return 1;;
      [sS]) return 2;;
      *) echo "â“ Press o, i, or s.";;
    esac
  done
}

convert_and_handle_conflict(){
  local input=$1 base out newW newH w h suffix
  base=${input%.*}
  suffix=$([ "$do_resize" = true ] && echo "-$maxDim" || echo "")
  out="${base}${suffix}.webp"

  # Determine resize params, if needed
  if $do_resize; then
    w=$(sips -g pixelWidth "$input"  | awk '/pixelWidth/  {print $2}')
    h=$(sips -g pixelHeight "$input" | awk '/pixelHeight/ {print $2}')
    if (( w >= h )); then newW=$maxDim; newH=0; else newW=0; newH=$maxDim; fi
  fi

  mkdir -p WEBP
  if [[ -e WEBP/$out ]]; then
    ask_conflict "$out"
    action=$?
    if (( action == 0 )); then
      : # overwrite
    elif (( action == 1 )); then
      local n=1
      while [[ -e WEBP/${base}${suffix}_$n.webp ]]; do ((n++)); done
      out="${base}${suffix}_$n.webp"
    else
      return 1
    fi
  fi

  # Run cwebp with -quiet; append resize flags if requested
  if $do_resize; then
    cwebp "${cwebp_opts[@]}" -resize $newW $newH "$input" -o "WEBP/$out"
  else
    cwebp "${cwebp_opts[@]}" "$input" -o "WEBP/$out"
  fi

  # Print concise per-file info: name, beforeâ†’after sizes
  local in_size out_size
  in_size=$(stat -f%z "$input")
  out_size=$(stat -f%z "WEBP/$out")
  printf "â–¶ %s: %s â†’ %s\n" \
    "$input" "$(human_size $in_size)" "$(human_size $out_size)"

  mv "$input" "$processed_dir"/
  return 0
}

# â”€â”€â”€ Directory Processing Function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
process_directory(){
  local dir=$1 jpgs pngs heics ghost f size
  echo "â”€â”€ Processing: $dir â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  cd "$dir" || { echo "âŒ Cannot cd into $dir"; return; }

  processed_dir=""  # will be set below

  # Ghost-file check
  ghosts=()
  for f in *.jpg(N) *.jpeg(N) *.png(N) *.JPG(N) *.JPEG(N) *.PNG(N); do
    [[ -e $f && ! -s $f ]] && ghosts+=("$f")
  done
  if (( ${#ghosts[@]} )); then
    echo "âš ï¸  ${#ghosts[@]} ghost files detected:"
    printf ' - %s\n' "${ghosts[@]}"
    read -q "?Proceed with downloaded files only? [y/N] " c; echo
    [[ $c != [yY] ]] && { echo "Skipping $dir"; cd - &>/dev/null; return; }
  fi

  # HEIC â†’ JPEG
  heics=( *.heic(N) *.HEIC(N) )
  if (( ${#heics[@]} )); then
    mkdir -p HEIC
    for f in "${heics[@]}"; do
      sips -s format jpeg "$f" --out "${f%.*}.jpg"
      mv "$f" HEIC/
    done
  fi

  # Initialize counts & sums
  jpgs=( *.jpg(N) *.JPG(N) *.jpeg(N) *.JPEG(N) )
  pngs=( *.png(N) *.PNG(N) )
  SUM_JPG[$dir]=0; SUM_PNG[$dir]=0; SUM_WEBP[$dir]=0; SUM_COUNT[$dir]=0

  # Create processed directories
  mkdir -p JPG PNG
  processed_dir="JPG"

  # Convert JPG/JPEG
  for f in "${jpgs[@]}"; do
    [[ -f $f ]] || continue
    SUM_COUNT[$dir]=$(( SUM_COUNT[$dir] + 1 ))
    SUM_JPG[$dir]=$(( SUM_JPG[$dir] + $(stat -f%z "$f") ))
    if convert_and_handle_conflict "$f"; then
      mv "WEBP/${f%.*}${suffix}.webp" WEBP/
    fi
  done

  # Convert PNG
  processed_dir="PNG"
  for f in "${pngs[@]}"; do
    [[ -f $f ]] || continue
    SUM_COUNT[$dir]=$(( SUM_COUNT[$dir] + 1 ))
    SUM_PNG[$dir]=$(( SUM_PNG[$dir] + $(stat -f%z "$f") ))
    if convert_and_handle_conflict "$f"; then
      mv "WEBP/${f%.*}${suffix}.webp" WEBP/
    fi
  done

  # Tally WEBP sizes
  for w in WEBP/*.webp(N); do
    SUM_WEBP[$dir]=$(( SUM_WEBP[$dir] + $(stat -f%z "$w") ))
  done

  dirs_processed+=("$dir")
  cd - &>/dev/null
}

# â”€â”€â”€ Prepare for Parallel Stats Collection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [[ $do_parallel = true ]]; then
  PARALLEL_TMPDIR=$(mktemp -d /tmp/webpCreate.XXXX)
  echo "ğŸ›   Parallel mode: writing per-dir stats to $PARALLEL_TMPDIR"
fi

# â”€â”€â”€ Main Loop: Parallel or Sequential â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [[ $do_parallel = true ]]; then
  for d in "${dirs[@]}"; do
    process_directory "$d" >"$PARALLEL_TMPDIR/$(basename "$d").log" 2>&1 &
  done
  wait
else
  for d in "${dirs[@]}"; do
    process_directory "$d"
  done
fi

# â”€â”€â”€ Final Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
echo; echo "# Final Conversion Summary"

if [[ -n $PARALLEL_TMPDIR ]]; then
  for stats in "$PARALLEL_TMPDIR"/*.log; do
    dir=$(basename "${stats%.log}")
    # Read the accumulated sums:
    orig=$(( SUM_JPG[$dir] + SUM_PNG[$dir] ))
    webp=${SUM_WEBP[$dir]}
    count=${SUM_COUNT[$dir]}
    saved=$(( orig - webp ))
    pct=$((( saved * 1000 / orig + 5 ) / 10 ))
    echo
    echo "â€¢ Directory: $dir"
    echo "   - Images processed:    $count"
    echo "   - Original total size: $(human_size $orig)"
    echo "   - WebP total size:     $(human_size $webp)"
    echo "   - Savings:             $(human_size $saved) ($pct% reduction)"
  done
  rm -rf "$PARALLEL_TMPDIR"
else
  for dir in "${dirs_processed[@]}"; do
    orig=$(( SUM_JPG[$dir] + SUM_PNG[$dir] ))
    webp=${SUM_WEBP[$dir]}
    count=${SUM_COUNT[$dir]}
    saved=$(( orig - webp ))
    pct=$((( saved * 1000 / orig + 5 ) / 10 ))
    echo
    echo "â€¢ Directory: $dir"
    echo "   - Images processed:    $count"
    echo "   - Original total size: $(human_size $orig)"
    echo "   - WebP total size:     $(human_size $webp)"
    echo "   - Savings:             $(human_size $saved) ($pct% reduction)"
  done
fi
