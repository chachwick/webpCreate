#!/usr/bin/env zsh
# webpCreate version: 1.12.0-beta
setopt null_glob

# â€¦rest of scriptâ€¦


# â”€â”€â”€ Help & Description â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
show_help() {
  cat <<-EOF
webpCreate: batch-convert images to WebP with concise progress and stats.
Usage:
  webpCreate [options] [dir1 dir2 ...]
  If no directories are given, defaults to the current directory.

Options:
  -h, --help            Show this help and exit  
  -q, --quality Q       Set cwebp quality (0â€“100; default 80)  
  --maxd N              Resize longest side to â‰¤ N px (skips prompt)  
  --lossless            Use cwebp -lossless  
  --mt, --multithread   Enable cwebp -mt (multiâ€threaded)  
  --cwoption OPT        Pass arbitrary OPT (e.g. "-af") to cwebp  
  --parallel, -P        Process multiple directories in parallel  
  --jpeg                Also create JPEG copies with same dimensions/quality  
  -o, --orientation     Orientation handling: detect (default), warn, ignore

Examples:
  webpCreate .  
  webpCreate -q 75 --maxd 1200 ~/Pictures ~/Downloads  
  webpCreate --parallel --lossless --mt dirA dirB  
  webpCreate --jpeg -q 85 --maxd 1600 ~/Photos  
  webpCreate -o warn --jpeg ~/Photos  
  webpCreate -o ignore ~/TrustedImages
EOF
}

# â”€â”€â”€ Flag Parsing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwebp_opts=(-quiet)   # start with -quiet to suppress verbose cwebp output
do_parallel=false
create_jpeg=false
orientation_mode="detect"  # default: detect, warn, ignore
dirs=()
quality=""
maxd_flag=""

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help) show_help; exit 0;;
    -q|--quality)       shift; quality=$1; cwebp_opts+=(-q $quality); shift;;
    --maxd)             shift; maxDim=$1; do_resize=true; maxd_flag="yes"; shift;;
    --lossless)         cwebp_opts+=(-lossless); shift;;
    --mt|--multithread) cwebp_opts+=(-mt); shift;;
    --cwoption)         shift; cwebp_opts+=("$1"); shift;;
    --parallel|-P)      do_parallel=true; shift;;
    --jpeg)             create_jpeg=true; shift;;
    -o|--orientation)   shift; orientation_mode=$1; shift;;
    --) shift; break;;
    -*) echo "Unknown option: $1"; exit 1;;
    *) dirs+=("$1"); shift;;
  esac
done

(( ${#dirs[@]} == 0 )) && dirs=(".")

# Validate orientation mode
case $orientation_mode in
  detect|warn|ignore) ;;
  *) echo "âŒ Invalid orientation mode: $orientation_mode. Use: detect, warn, or ignore"; exit 1;;
esac

# â”€â”€â”€ Resize Prompt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [[ -z $maxd_flag ]]; then
  read -q "?Would you like to resize images so their longest side is capped? [y/N] " resize_choice
  echo
  if [[ $resize_choice =~ ^[Yy]$ ]]; then
    read -r "?Enter max dimension (pixels) for longest side (e.g. 1200): " maxDim
    [[ "$maxDim" =~ ^[0-9]+$ ]] || { echo "âŒ Invalid number: $maxDim"; exit 1; }
    do_resize=true
  else
    do_resize=false
  fi
else
  do_resize=true
fi

# â”€â”€â”€ Dependency Checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for cmd in cwebp sips; do
  if ! command -v $cmd &>/dev/null; then
    brew_cmd=${cmd==cwebp?webp:imagemagick}
    echo "âŒ Missing '$cmd'. Install with: brew install $brew_cmd"
    echo "   Or run installer: bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)"
    exit 1
  fi
done

# â”€â”€â”€ Utilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
human_size(){
  local b=$1
  printf "%d.%02d MB" $((b/1024/1024)) $(((b/1024)%1024*100/1024))
}

# Enhanced orientation detection using multiple metadata sources
detect_orientation(){
  local file=$1
  local exif_orient sips_orient mdls_orient final_orient
  
  # Try EXIF orientation first
  exif_orient=$(sips -g orientation "$file" 2>/dev/null | awk '/orientation/ {print $2}')
  
  if [[ "$exif_orient" != "<nil>" && "$exif_orient" != "" ]]; then
    echo "$exif_orient"
    return
  fi
  
  # Try macOS metadata 
  mdls_orient=$(mdls "$file" 2>/dev/null | grep -i "kMDItemOrientation" | awk '{print $NF}')
  if [[ "$mdls_orient" != "" && "$mdls_orient" != "(null)" ]]; then
    echo "$mdls_orient"
    return
  fi
  
  # Check for other orientation indicators in metadata
  # Some cameras store orientation in different EXIF fields
  if command -v exiftool >/dev/null 2>&1; then
    final_orient=$(exiftool "$file" 2>/dev/null | grep -i "orientation" | head -1 | awk -F: '{print $2}' | xargs)
    if [[ "$final_orient" != "" ]]; then
      case "$final_orient" in
        "Horizontal (normal)"|"1") echo "1";;
        "Rotate 90 CW"|"6") echo "6";;
        "Rotate 180"|"3") echo "3";;
        "Rotate 270 CW"|"8") echo "8";;
        *) echo "<nil>";;
      esac
      return
    fi
  fi
  
  # No orientation metadata found
  echo "<nil>"
}

ask_conflict(){
  local file=$1 choice
  while true; do
    echo "âš ï¸  WEBP/$file exists. (o)verwrite / (i)ncrement / (s)kip?"
    read -sk1 choice; echo
    case $choice in
      [oO]) return 0;;
      [iI]) return 1;;
      [sS]) return 2;;
      *) echo "â“ Press o, i, or s.";;
    esac
  done
}

# â”€â”€â”€ Convert + Conflict Handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
convert_and_handle_conflict(){
  local input=$1 base out newW newH w h suffix temp_input
  base=${input%.*}
  suffix=$([ "$do_resize" = true ] && echo "-$maxDim" || echo "")
  out="${base}${suffix}.webp"
  temp_input="$input"

  # Compute resize dimensions if needed
  if $do_resize; then
    w=$(sips -g pixelWidth "$input"  | awk '/pixelWidth/  {print $2}')
    h=$(sips -g pixelHeight "$input" | awk '/pixelHeight/ {print $2}')
    if (( w >= h )); then newW=$maxDim; newH=0; else newW=0; newH=$maxDim; fi
  fi

  # Create temporary image with orientation handling based on user preference
  temp_input="${base}_temp.jpg"
  
  case $orientation_mode in
    "ignore")
      # User wants no orientation processing - preserve exact image data
      if $do_resize; then
        sips -Z $maxDim "$input" --out "$temp_input" >/dev/null 2>&1
      else
        cp "$input" "$temp_input"
      fi
      ;;
      
    "warn")
      # Detect orientation issues and warn user, but don't auto-fix
      detected_orient=$(detect_orientation "$input")
      
      # Check for potential orientation mismatch
      if [[ "$detected_orient" == "<nil>" ]] && (( (w > h && w > 2000) || (h > w && h > 2000) )); then
        echo "âš ï¸  Warning: $input has no orientation metadata"
        echo "   File dimensions: ${w}Ã—${h}, Preview may auto-rotate for display"
        echo "   WebP output may not match Preview appearance"
      fi
      
      # Process without orientation correction
      if $do_resize; then
        sips -Z $maxDim "$input" --out "$temp_input" >/dev/null 2>&1
      else
        cp "$input" "$temp_input"
      fi
      ;;
      
    "detect")
      # Enhanced orientation detection and correction (default)
      detected_orient=$(detect_orientation "$input")
      
      if [[ "$detected_orient" != "<nil>" && "$detected_orient" != "" && "$detected_orient" != "1" ]]; then
        # Orientation metadata found - apply it
        if $do_resize; then
          sips -Z $maxDim "$input" --out "$temp_input" >/dev/null 2>&1
        else
          sips -s format jpeg -s formatOptions 100 "$input" --out "$temp_input" >/dev/null 2>&1
        fi
        # Normalize orientation after applying transformation
        sips -s orientation 1 "$temp_input" >/dev/null 2>&1
      else
        # No orientation metadata - check for dimension/display mismatch
        if $do_resize; then
          sips -Z $maxDim "$input" --out "$temp_input" >/dev/null 2>&1
        else
          cp "$input" "$temp_input"
        fi
        
        # For images without metadata, check if they might need correction
        # This is conservative - only fix obvious mismatches
        temp_w=$(sips -g pixelWidth "$temp_input" 2>/dev/null | awk '/pixelWidth/ {print $2}')
        temp_h=$(sips -g pixelHeight "$temp_input" 2>/dev/null | awk '/pixelHeight/ {print $2}')
        
        if [[ -n "$temp_w" && -n "$temp_h" ]]; then
          # Only attempt correction for large dimension differences that suggest camera rotation
          if (( h > w && temp_w > temp_h && (temp_w - temp_h) > 500 )); then
            # Likely a rotated portrait that should be portrait
            sips --rotate 90 "$temp_input" >/dev/null 2>&1
          elif (( w > h && temp_h > temp_w && (temp_h - temp_w) > 500 )); then
            # Likely a rotated landscape that should be landscape
            sips --rotate -90 "$temp_input" >/dev/null 2>&1
          fi
        fi
      fi
      ;;
  esac

  mkdir -p WEBP
  if [[ -e WEBP/$out ]]; then
    ask_conflict "$out"
    action=$?
    if (( action == 0 )); then
      :  # overwrite
    elif (( action == 1 )); then
      local n=1
      while [[ -e WEBP/${base}${suffix}_$n.webp ]]; do ((n++)); done
      out="${base}${suffix}_$n.webp"
    else
      rm -f "$temp_input"
      return 1
    fi
  fi

  # Run cwebp quietly with the temp file (which preserves EXIF orientation)
  cwebp "${cwebp_opts[@]}" "$temp_input" -o "WEBP/$out"

  # Create JPEG copy if requested
  if $create_jpeg; then
    local jpeg_out="${base}${suffix}.jpg"
    local jpeg_quality=${quality:-80}
    
    mkdir -p JPG
    
    # Handle JPEG filename conflicts
    if [[ -e JPG/$jpeg_out ]]; then
      ask_conflict "$jpeg_out"
      local jpeg_action=$?
      if (( jpeg_action == 0 )); then
        :  # overwrite
      elif (( jpeg_action == 1 )); then
        local n=1
        while [[ -e JPG/${base}${suffix}_$n.jpg ]]; do ((n++)); done
        jpeg_out="${base}${suffix}_$n.jpg"
      fi
      
      if (( jpeg_action != 2 )); then  # not skip
        # Create JPEG with same quality and dimensions as WebP
        sips -s formatOptions $jpeg_quality "$temp_input" --out "JPG/$jpeg_out" >/dev/null 2>&1
      fi
    else
      # Create JPEG with same quality and dimensions as WebP
      sips -s formatOptions $jpeg_quality "$temp_input" --out "JPG/$jpeg_out" >/dev/null 2>&1
    fi
  fi

  # Clean up temp file
  rm -f "$temp_input"
  # Print concise info: filename, beforeâ†’after sizes
  local in_size out_size
  in_size=$(stat -f%z "$input")
  out_size=$(stat -f%z "WEBP/$out")
  printf "â–¶ %s: %s â†’ %s\n" \
    "$input" "$(human_size $in_size)" "$(human_size $out_size)"

  return 0
}

# â”€â”€â”€ Directory Processing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
process_directory(){
  local dir=$1 f size orig_size webp_size count=0
  echo "â”€â”€ Processing: $dir â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  cd "$dir" || { echo "âŒ Cannot cd into $dir"; return; }

  # Ghost-file check
  local ghosts=()
  for f in *.jpg(N) *.jpeg(N) *.png(N) *.JPG(N) *.JPEG(N) *.PNG(N); do
    [[ -e $f && ! -s $f ]] && ghosts+=("$f")
  done
  if (( ${#ghosts[@]} )); then
    echo "âš ï¸  ${#ghosts[@]} ghost files detected:"
    printf ' - %s\n' "${ghosts[@]}"
    read -q "?Proceed with downloaded files only? [y/N] " c; echo
    [[ $c != [yY] ]] && { echo "Skipping $dir"; cd - &>/dev/null; return; }
  fi

  # HEIC â†’ JPEG
  local heics=( *.heic(N) *.HEIC(N) )
  if (( ${#heics[@]} )); then
    mkdir -p HEIC
    for f in "${heics[@]}"; do
      sips -s format jpeg "$f" --out "${f%.*}.jpg"
      mv "$f" HEIC/
    done
  fi

  # Initialize sums
  orig_size=0; webp_size=0

  # Convert JPG/JPEG only if present
  local jpgs=( *.jpg(N) *.JPG(N) *.jpeg(N) *.JPEG(N) )
  if (( ${#jpgs[@]} )); then
    mkdir -p JPG
    for f in "${jpgs[@]}"; do
      [[ -f $f ]] || continue
      (( count++ ))
      orig_size=$(( orig_size + $(stat -f%z "$f") ))
      if convert_and_handle_conflict "$f"; then
        mv "$f" JPG/
      fi
    done
  fi

  # Convert PNG only if present
  local pngs=( *.png(N) *.PNG(N) )
  if (( ${#pngs[@]} )); then
    mkdir -p PNG
    for f in "${pngs[@]}"; do
      [[ -f $f ]] || continue
      (( count++ ))
      orig_size=$(( orig_size + $(stat -f%z "$f") ))
      if convert_and_handle_conflict "$f"; then
        mv "$f" PNG/
      fi
    done
  fi

  # Tally WEBP sizes only if WEBP folder exists
  if [[ -d WEBP ]]; then
    for w in WEBP/*.webp(N); do
      webp_size=$(( webp_size + $(stat -f%z "$w") ))
    done
  fi
  # In parallel mode, write a .stats file; otherwise collect in arrays
  if [[ -n $PARALLEL_TMPDIR ]]; then
    printf "%s|%d|%d|%d\n" "$dir" "$count" "$orig_size" "$webp_size" \
      > "$PARALLEL_TMPDIR/$(basename "$dir").stats"
  else
    SUM_COUNT[$dir]=$count
    SUM_JPG[$dir]=$orig_size
    SUM_WEBP[$dir]=$webp_size
    dirs_processed+=("$dir")
  fi

  cd - &>/dev/null
}

# â”€â”€â”€ Prepare for Parallel Stats Collection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [[ $do_parallel = true ]]; then
  PARALLEL_TMPDIR=$(mktemp -d /tmp/webpCreate.XXXX)
  echo "ğŸ›   Parallel mode: writing per-dir stats to $PARALLEL_TMPDIR"
fi

# â”€â”€â”€ Main Loop: Parallel or Sequential â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [[ $do_parallel = true ]]; then
  for d in "${dirs[@]}"; do
    process_directory "$d" &
  done
  wait
else
  for d in "${dirs[@]}"; do
    process_directory "$d"
  done
fi

# â”€â”€â”€ Final Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
echo
echo "# Final Conversion Summary"

if [[ -n $PARALLEL_TMPDIR ]]; then
  for stats in "$PARALLEL_TMPDIR"/*.stats; do
    IFS='|' read -r dir count orig webp < "$stats"
    saved=$(( orig - webp ))
    if (( orig > 0 )); then
      pct=$((( saved * 1000 / orig + 5 ) / 10 ))
    else
      pct=0
    fi
    echo
    echo "â€¢ Directory: $dir"
    echo "   - Images processed:    $count"
    echo "   - Original total size: $(human_size $orig)"
    echo "   - WebP total size:     $(human_size $webp)"
    echo "   - Savings:             $(human_size $saved) ($pct% reduction)"
  done
  rm -rf "$PARALLEL_TMPDIR"
else
  for dir in "${dirs_processed[@]}"; do
    count=${SUM_COUNT[$dir]}
    orig=${SUM_JPG[$dir]}
    webp=${SUM_WEBP[$dir]}
    saved=$(( orig - webp ))
    if (( orig > 0 )); then
      pct=$((( saved * 1000 / orig + 5 ) / 10 ))
    else
      pct=0
    fi
    echo
    echo "â€¢ Directory: $dir"
    echo "   - Images processed:    $count"
    echo "   - Original total size: $(human_size $orig)"
    echo "   - WebP total size:     $(human_size $webp)"
    echo "   - Savings:             $(human_size $saved) ($pct% reduction)"
  done
fi
