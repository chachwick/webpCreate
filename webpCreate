#!/usr/bin/env zsh
setopt null_glob

# ─── Help & Description ──────────────────────────────────────────────────────────
show_help() {
  cat <<-EOF
webpCreate: batch-convert images to WebP with organization & stats.

What it does:
  • Converts .jpg/.jpeg/.png (case-insensitive) and HEIC → JPEG (via sips)  
  • Organizes originals into JPG/, PNG/, HEIC/ and outputs into WEBP/  
  • Handles filename conflicts (overwrite/increment/skip)  
  • Optionally resizes so longest side ≤ max dimension  
  • Reports per-directory file counts & size savings

Why WebP?
  WebP delivers excellent compression for web images—smaller files,
  faster pages, modern browser support. This script automates the
  end-to-end workflow and gives you clear savings data.

Usage:
  webpCreate [options] [dir1 dir2 ...]
  If no directories are given, defaults to the current directory.
  
  Full documentation & examples: https://github.com/chachwick/webpCreate#readme

Installation & Updates:
  • Initial install:  
      bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)  
  • For updates, run the companion command:  
      update-webpCreate  

Options:
  -h, --help            Show this help and exit
  --lossless            Use cwebp’s -lossless mode
  --mt, --multithread   Enable intra-file multi-threading (-mt)
  --cwoption OPT        Pass OPT (e.g. "-q 90" or "-af") to cwebp
  --parallel, -P        Process multiple directories in parallel

Examples:
  webpCreate .  
  webpCreate ~/Pics /tmp/foo /bar  
  webpCreate --parallel --lossless ~/Downloads
EOF
}

# ─── Flag Parsing ───────────────────────────────────────────────────────────────
cwebp_opts=()
do_parallel=false
dirs=()

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help) show_help; exit 0;;
    --lossless)              cwebp_opts+=(-lossless); shift;;
    --mt|--multithread)      cwebp_opts+=(-mt);        shift;;
    --cwoption)              shift; cwebp_opts+=("$1"); shift;;
    --parallel|-P)           do_parallel=true;        shift;;
    --) shift; break;;
    -*) echo "Unknown option: $1"; exit 1;;
    *) dirs+=("$1"); shift;;
  esac
done

(( ${#dirs[@]} == 0 )) && dirs=(".")

# ─── Resize Prompt ─────────────────────────────────────────────────────────────
read -q "?Would you like to resize images so their longest side is capped? [y/N] " resize_choice
echo
if [[ $resize_choice =~ ^[Yy]$ ]]; then
  read -r "?Enter max dimension (pixels) for longest side (e.g. 1200): " maxDim
  [[ "$maxDim" =~ ^[0-9]+$ ]] || { echo "❌ Invalid number: $maxDim"; exit 1; }
  do_resize=true
else
  do_resize=false
fi

# ─── Dependency Checks ──────────────────────────────────────────────────────────
for cmd in cwebp sips; do
  if ! command -v $cmd &>/dev/null; then
    brew_cmd=${cmd==cwebp?webp:imagemagick}
    echo "❌ Missing '$cmd'. Install with: brew install $brew_cmd"
    echo "   Or run installer: bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)"
    exit 1
  fi
done

# (rest of your conversion logic remains unchanged…)

# --- Start Processing ---
echo "🛠  Running webpCreate in: $(pwd)"

# Early ghost file detection
jpg_patterns=( *.jpg(N) *.JPG(N) *.jpeg(N) *.JPEG(N) )
png_patterns=( *.png(N) *.PNG(N) )
heic_patterns=( *.heic(N) *.HEIC(N) )
all_patterns=( "${jpg_patterns[@]}" "${png_patterns[@]}" "${heic_patterns[@]}" )
ghosts=()
for f in "${all_patterns[@]}"; do
  [[ -e $f && ! -s $f ]] && ghosts+=("$f")
done
if (( ${#ghosts[@]} > 0 )); then
  echo "⚠️ Detected ${#ghosts[@]} ghost files:"
  printf ' - %s\n' "${ghosts[@]}"
  echo "1) Continue with downloaded files only"
  echo "2) Quit and sync files first"
  echo -n "Choice [1/2]: "; read choice
  [[ $choice == 1 ]] || { echo "Exiting."; exit 0; }
fi

# Determine scaling
if $askScale; then
  echo -n "Resize images? (y/n): "; read scaleChoice
  if [[ "$scaleChoice" =~ ^[Yy] ]]; then
    echo -n "Max dimension (px): "; read maxDim
    [[ "$maxDim" =~ ^[0-9]+$ ]] || { echo "Invalid number."; exit 1; }
    echo "Scaling to ${maxDim}px."
  else
    maxDim=0; echo "No resizing."
  fi
else
  (( maxDim > 0 )) && echo "Auto-scaling to ${maxDim}px." || echo "No resizing."
fi

# Convert HEIC to JPEG
heic_files=( "${heic_patterns[@]}" )
if (( ${#heic_files[@]} )); then
  mkdir -p HEIC JPG
  echo "Converting HEIC to JPEG..."
  for f in "${heic_files[@]}"; do
    [[ -f $f && -s $f ]] || continue
    sips -s format jpeg "$f" --out "${f%.*}.jpg" >/dev/null
    mv "$f" HEIC/
  done
fi

# Initialize counters
jpg_count=0; png_count=0; webp_count=0
jpg_size=0; png_size=0; webp_size=0
human_size(){ printf "%d.%02d MB" $(( $1/1024/1024 )) $((( $1/1024)%1024*100/1024)); }
ask_file_action(){ while true; do
  echo "WEBP/$1 exists. (o)verwrite/(i)ncrement/(s)kip?"; read -sk1 c; echo
  case $c in [oO]) return 0;; [iI]) return 1;; [sS]) return 2;; *) echo "Choose o,i or s.";; esac
done }
convert_and_handle_conflict(){ local in=$1 base=${in%.*} suffix=$([[ $maxDim -gt 0 ]]&&echo -$maxDim) out=${base}${suffix}.webp
  local rf=(); if (( maxDim )); then parse_dims; rf=("-resize" "$newW" "$newH"); fi
  mkdir -p WEBP
  [[ -e WEBP/$out ]] && ask_file_action "$out" && action=$? && { ((action==1))&&increment_out; ((action!=2))&&cwebp_run; } || cwebp_run && mv "$out" WEBP/
}
parse_dims(){ w=$(sips -g pixelWidth "$in"|awk '/pixelWidth/{print$2}'); h=$(sips -g pixelHeight "$in"|awk '/pixelHeight/{print$2}');((w>=h))&&newW=$maxDim&&newH=0||newW=0&&newH=$maxDim; }
increment_out(){ n=1; while [[ -e WEBP/${base}${suffix}_$n.webp ]]; do ((n++)); done; out=${base}${suffix}_$n.webp; cwebp_run; mv "$out" WEBP/; }
cwebp_run(){ cwebp -q $QUALITY "${CWOPTS[@]}" "${rf[@]}" "$in" -o "$out"; }

# Build file lists
ojg=( $(printf "%s\n" "${jpg_patterns[@]}"|while read f;do [[ -f $f && -s $f ]]&&echo $f;done) )
png=( $(printf "%s\n" "${png_patterns[@]}"|while read f;do [[ -f $f && -s $f ]]&&echo $f;done) )

# Process JPGs
(( ${#ojg[@]} ))&&mkdir -p JPG&&for file in "${ojg[@]}";do sz=$(stat -f%z "$file"); echo Converting $file; convert_and_handle_conflict "$file"&&mv "$file" JPG/&&((jpg_count++,jpg_size+=sz)); done
# Process PNGs
(( ${#png[@]} ))&&mkdir -p PNG&&for file in "${png[@]}";do sz=$(stat -f%z "$file"); echo Converting $file; convert_and_handle_conflict "$file"&&mv "$file" PNG/&&((png_count++,png_size+=sz)); done

# Count WEBP
echo; for w in WEBP/*.webp(N);do((webp_count++,webp_size+=$(stat -f%z "$w")));done

# Summary
tot=$((jpg_size+png_size)); saved=$((tot-webp_size));
echo "\n✅ Summary:"; ((jpg_count))&&echo " - JPGs: $jpg_count → $(human_size $jpg_size)"; ((png_count))&&echo " - PNGs: $png_count → $(human_size $png_size)"; ((webp_count))&&echo " - WEBP: $webp_count → $(human_size $webp_size)"; ((tot>0&&webp_size>0))&&echo " - Savings: $(human_size $saved) ($(printf "%.1f%%" $(echo "$saved/$tot*100"|bc -l)))"
