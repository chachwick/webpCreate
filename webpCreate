#!/bin/zsh
setopt null_glob

# --- Default Configuration ---
QUALITY=80         # default quality, use --cwoption to override
askScale=true
maxDim=0
updateOnly=false
CWOPTS=()          # additional cwebp options

# --- Parse Command-Line Options ---
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      cat << 'EOF'
Usage: webpCreate [options]

Options:
  --update               Update script from GitHub and exit
  --maxd <pixels>        Max dimension for longest side (skip resize prompt)
  --lossless             Add cwebp -lossless flag
  --cwoption <opt>       Pass custom option to cwebp (e.g. -af or "-z 9")
  -h, --help             Show this help message and exit

Examples:
  webpCreate --maxd 1200 --cwoption "-q 75"    # resize and quality
  webpCreate --lossless --cwoption "-af"       # lossless with auto-filter
  webpCreate -h                                 # show this help

For full cwebp options, see:
  ‚Ä¢ WebP docs: https://developers.google.com/speed/webp/docs/cwebp
  ‚Ä¢ Manual: man cwebp

If missing dependencies, run:
  brew install webp ffmpeg  # for cwebp and HEIC support
  bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)
EOF
      exit 0
      ;;
    --update)
      updateOnly=true; shift;;
    --maxd)
      if [[ "$2" =~ ^[0-9]+$ ]]; then
        askScale=false; maxDim=$2; shift 2
      else
        echo "‚ùå --maxd requires a numeric argument."; exit 1
      fi;;
    --lossless)
      CWOPTS+=(-lossless); shift;;
    --cwoption)
      if [[ -n "$2" ]]; then
        CWOPTS+=("$2"); shift 2
      else
        echo "‚ùå --cwoption requires an argument (e.g. -af)"; exit 1
      fi;;
    *)
      echo "‚ùå Unknown option: $1"; echo "Run with --help or -h for usage."; exit 1;;
  esac
done

# --- Update Logic ---
if $updateOnly; then
  echo "üîÑ Updating webpCreate to latest version from GitHub..."
  mkdir -p "$HOME/scripts"
  curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/webpCreate -o "$HOME/scripts/webpCreate"
  chmod +x "$HOME/scripts/webpCreate"
  source "$HOME/.zshrc" 2>/dev/null || true
  echo "‚úÖ webpCreate updated."
  exit 0
fi

# --- Description ---
# webpCreate: Batch-converts images to WebP, optimizes for web delivery, and organizes originals.
# Why WebP?
#   WebP is a modern image format with superior compression, reducing file sizes
#   for faster web page loads with no significant quality loss. It supports
#   lossy and lossless modes.
# What this script does:
#   1. Converts HEIC to JPEG (moves HEIC originals to HEIC/)
#   2. Converts JPG/JPEG/PNG to WebP (optional resize)
#   3. Handles filename conflicts (overwrite/increment/skip)
#   4. Organizes originals into JPG/ and PNG/ folders; outputs WebP to WEBP/
# Usage: webpCreate [options]

# --- Dependency Checks ---
echo "üß© Checking dependencies..."
if ! command -v cwebp &> /dev/null; then
  echo "‚ùå cwebp not found. Install: brew install webp"
  echo "   or run installer: bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)"
  exit 1
fi
if ! command -v sips &> /dev/null; then
  echo "‚ùå sips not found (macOS only)."
  exit 1
fi
if ! command -v ffmpeg &> /dev/null; then
  echo "‚ö†Ô∏è  ffmpeg not found. For HEIC support: brew install ffmpeg"
fi

# --- Start Processing ---
echo "üõ†  Running webpCreate in: $(pwd)"

# Early ghost file detection
jpg_patterns=( *.jpg(N) *.JPG(N) *.jpeg(N) *.JPEG(N) )
png_patterns=( *.png(N) *.PNG(N) )
heic_patterns=( *.heic(N) *.HEIC(N) )
all_patterns=( "${jpg_patterns[@]}" "${png_patterns[@]}" "${heic_patterns[@]}" )
ghosts=()
for f in "${all_patterns[@]}"; do
  [[ -e $f && ! -s $f ]] && ghosts+=("$f")
done
if (( ${#ghosts[@]} > 0 )); then
  echo "‚ö†Ô∏è Detected ${#ghosts[@]} ghost files:"
  printf ' - %s\n' "${ghosts[@]}"
  echo "1) Continue with downloaded files only"
  echo "2) Quit and sync files first"
  echo -n "Choice [1/2]: "; read choice
  [[ $choice == 1 ]] || { echo "Exiting."; exit 0; }
fi

# Determine scaling
if $askScale; then
  echo -n "Resize images? (y/n): "; read scaleChoice
  if [[ "$scaleChoice" =~ ^[Yy] ]]; then
    echo -n "Max dimension (px): "; read maxDim
    [[ "$maxDim" =~ ^[0-9]+$ ]] || { echo "Invalid number."; exit 1; }
    echo "Scaling to ${maxDim}px."
  else
    maxDim=0; echo "No resizing."
  fi
else
  (( maxDim > 0 )) && echo "Auto-scaling to ${maxDim}px." || echo "No resizing."
fi

# Convert HEIC to JPEG
heic_files=( "${heic_patterns[@]}" )
if (( ${#heic_files[@]} )); then
  mkdir -p HEIC JPG
  echo "Converting HEIC to JPEG..."
  for f in "${heic_files[@]}"; do
    [[ -f $f && -s $f ]] || continue
    sips -s format jpeg "$f" --out "${f%.*}.jpg" >/dev/null
    mv "$f" HEIC/
  done
fi

# Initialize counters
jpg_count=0; png_count=0; webp_count=0
jpg_size=0; png_size=0; webp_size=0
human_size(){ printf "%d.%02d MB" $(( $1/1024/1024 )) $((( $1/1024)%1024*100/1024)); }
ask_file_action(){ while true; do
  echo "WEBP/$1 exists. (o)verwrite/(i)ncrement/(s)kip?"; read -sk1 c; echo
  case $c in [oO]) return 0;; [iI]) return 1;; [sS]) return 2;; *) echo "Choose o,i or s.";; esac
done }
convert_and_handle_conflict(){ local in=$1 base=${in%.*} suffix=$([[ $maxDim -gt 0 ]]&&echo -$maxDim) out=${base}${suffix}.webp
  local rf=(); if (( maxDim )); then parse_dims; rf=("-resize" "$newW" "$newH"); fi
  mkdir -p WEBP
  [[ -e WEBP/$out ]] && ask_file_action "$out" && action=$? && { ((action==1))&&increment_out; ((action!=2))&&cwebp_run; } || cwebp_run && mv "$out" WEBP/
}
parse_dims(){ w=$(sips -g pixelWidth "$in"|awk '/pixelWidth/{print$2}'); h=$(sips -g pixelHeight "$in"|awk '/pixelHeight/{print$2}');((w>=h))&&newW=$maxDim&&newH=0||newW=0&&newH=$maxDim; }
increment_out(){ n=1; while [[ -e WEBP/${base}${suffix}_$n.webp ]]; do ((n++)); done; out=${base}${suffix}_$n.webp; cwebp_run; mv "$out" WEBP/; }
cwebp_run(){ cwebp -q $QUALITY "${CWOPTS[@]}" "${rf[@]}" "$in" -o "$out"; }

# Build file lists
ojg=( $(printf "%s\n" "${jpg_patterns[@]}"|while read f;do [[ -f $f && -s $f ]]&&echo $f;done) )
png=( $(printf "%s\n" "${png_patterns[@]}"|while read f;do [[ -f $f && -s $f ]]&&echo $f;done) )

# Process JPGs
(( ${#ojg[@]} ))&&mkdir -p JPG&&for file in "${ojg[@]}";do sz=$(stat -f%z "$file"); echo Converting $file; convert_and_handle_conflict "$file"&&mv "$file" JPG/&&((jpg_count++,jpg_size+=sz)); done
# Process PNGs
(( ${#png[@]} ))&&mkdir -p PNG&&for file in "${png[@]}";do sz=$(stat -f%z "$file"); echo Converting $file; convert_and_handle_conflict "$file"&&mv "$file" PNG/&&((png_count++,png_size+=sz)); done

# Count WEBP
echo; for w in WEBP/*.webp(N);do((webp_count++,webp_size+=$(stat -f%z "$w")));done

# Summary
tot=$((jpg_size+png_size)); saved=$((tot-webp_size));
echo "\n‚úÖ Summary:"; ((jpg_count))&&echo " - JPGs: $jpg_count ‚Üí $(human_size $jpg_size)"; ((png_count))&&echo " - PNGs: $png_count ‚Üí $(human_size $png_size)"; ((webp_count))&&echo " - WEBP: $webp_count ‚Üí $(human_size $webp_size)"; ((tot>0&&webp_size>0))&&echo " - Savings: $(human_size $saved) ($(printf "%.1f%%" $(echo "$saved/$tot*100"|bc -l)))"
