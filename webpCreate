#!/bin/zsh
setopt null_glob

# --- Configuration ---
# Quality for cwebp
QUALITY=80

echo "üõ†  Running webpCreate in: $(pwd)"

# --- Early Ghost File Detection ---
jpg_patterns=( *.jpg(N) *.JPG(N) *.jpeg(N) *.JPEG(N) )
png_patterns=( *.png(N) *.PNG(N) )
heic_patterns=( *.heic(N) *.HEIC(N) )
all_patterns=( "${jpg_patterns[@]}" "${png_patterns[@]}" "${heic_patterns[@]}" )

ghosts=()
for f in "${all_patterns[@]}"; do
  [[ -e $f && ! -s $f ]] && ghosts+=("$f")
done

if (( ${#ghosts[@]} > 0 )); then
  echo "‚ö†Ô∏è  Detected ${#ghosts[@]} ghost (not downloaded) file(s):"
  printf ' - %s\n' "${ghosts[@]}"
  echo ""
  echo "What would you like to do?"
  echo "  [1] Continue with downloaded files only"
  echo "  [2] Quit and sync these files first (may use lots of drive space)"
  echo "  [3] Quit"
  echo -n "Enter choice [1/2/3]: "
  read choice
  case $choice in
    1) echo "‚úÖ Proceeding with available files only...";;
    2) echo "üëã Please download those files (e.g. open them in Finder), then re-run."; exit 0;;
    *) echo "üëã Exiting."; exit 0;;
  esac
fi

# --- Ask for maximum dimension resizing ---
echo -n "Enter maximum dimension (in pixels) for the longest side, e.g. 1200: "
read maxDim
if ! [[ "$maxDim" =~ ^[0-9]+$ ]]; then
  echo "‚ùå Invalid number: $maxDim"; exit 1
fi

echo "‚ôªÔ∏è  Will resize images so their longest side is ${maxDim}px."

# --- Ensure dependencies ---
if ! command -v cwebp &> /dev/null; then
  echo "‚ùå cwebp not found. Install with: brew install webp"
  exit 1
fi

# --- Create HEIC folder and convert HEIC to JPEG ---
heic_files=( "${heic_patterns[@]}" )
if (( ${#heic_files[@]} > 0 )); then
  echo "‚û°Ô∏è  Converting HEIC files to JPEG..."
  mkdir -p HEIC JPG
  for f in "${heic_files[@]}"; do
    [[ -f $f && -s $f ]] || continue
    # Convert to JPEG
    base="${f%.*}.jpg"
    sips -s format jpeg "$f" --out "$base" >/dev/null 2>&1
    # Move original HEIC into HEIC folder
    mv "$f" HEIC/
    # Track size
    heic_size=$(stat -f%z "HEIC/$f")
  done
fi

# --- Initialize counters & accumulators ---
jpg_count=0; png_count=0; webp_count=0
jpg_size=0; png_size=0; webp_size=0

human_size() {
  local bytes=$1
  printf "%d.%02d MB" $((bytes/1024/1024)) $(((bytes/1024)%1024*100/1024))
}

ask_file_action() {
  local file="$1"
  while true; do
    echo "‚ö†Ô∏è  WEBP/$file exists. (o)verwrite / (i)ncrement / (s)kip?"
    read -sk1 choice; echo ""
    case $choice in
      [oO]) return 0 ;;  # overwrite
      [iI]) return 1 ;;  # increment
      [sS]) return 2 ;;  # skip
      *) echo "‚ùì Press o, i, or s." ;;
    esac
  done
}

convert_and_handle_conflict() {
  local input="$1"
  local base="${input%.*}"
  local out="${base}-${maxDim}.webp"

  # determine resize dims
  local w h newW newH
  w=$(sips -g pixelWidth  "$input" | awk '/pixelWidth/ {print $2}')
  h=$(sips -g pixelHeight "$input" | awk '/pixelHeight/ {print $2}')
  if (( w >= h )); then
    newW=$maxDim; newH=0
  else
    newW=0; newH=$maxDim
  fi

  mkdir -p WEBP
  if [[ -e "WEBP/$out" ]]; then
    ask_file_action "$out"
    action=$?
    if   [[ $action -eq 0 ]]; then
      cwebp -q $QUALITY -resize $newW $newH "$input" -o "$out"
    elif [[ $action -eq 1 ]]; then
      n=1
      while [[ -e "WEBP/${base}-${maxDim}_$n.webp" ]]; do ((n++)); done
      out="${base}-${maxDim}_$n.webp"
      cwebp -q $QUALITY -resize $newW $newH "$input" -o "$out"
    else
      return 1
    fi
  else
    cwebp -q $QUALITY -resize $newW $newH "$input" -o "$out"
  fi

  mv "$out" WEBP/ && return 0
  return 1
}

# --- Build lists of ready files ---
jpg_patterns=( *.jpg(N) *.JPG(N) *.jpeg(N) *.JPEG(N) )
png_patterns=( *.png(N) *.PNG(N) )
jpg_files=(); png_files=()
for f in "${jpg_patterns[@]}"; do [[ -f $f && -s $f ]] && jpg_files+=("$f"); done
for f in "${png_patterns[@]}"; do [[ -f $f && -s $f ]] && png_files+=("$f"); done

# --- Convert JPG/JPEG variants ---
if (( ${#jpg_files[@]} > 0 )); then
  mkdir -p JPG
  for file in "${jpg_files[@]}"; do
    size=$(stat -f%z "$file")
    echo "‚û°Ô∏è Converting $file"
    if convert_and_handle_conflict "$file"; then
      mv "$file" JPG/
      ((jpg_count++)); ((jpg_size+=size))
    fi
  done
else
  echo "‚ö†Ô∏è No JPG/JPEG files to process."
fi

# --- Convert PNG variants ---
if (( ${#png_files[@]} > 0 )); then
  mkdir -p PNG
  for file in "${png_files[@]}"; do
    size=$(stat -f%z "$file")
    echo "‚û°Ô∏è Converting $file"
    if convert_and_handle_conflict "$file"; then
      mv "$file" PNG/
      ((png_count++)); ((png_size+=size))
    fi
  done
else
  echo "‚ö†Ô∏è No PNG files to process."
fi

# --- Tally WEBP outputs ---
webp_files=( WEBP/*.webp(N) )
for w in "${webp_files[@]}"; do
  ((webp_count++)); webp_size=$((webp_size + $(stat -f%z "$w")))
done

# --- Final Summary ---
total_input=$((jpg_size + png_size))
total_saved=$((total_input - webp_size))

echo ""
echo "‚úÖ Conversion Summary:"
(( jpg_count  > 0 )) && echo " - Converted JPG/JPEG files: $jpg_count ‚Üí $(human_size $jpg_size)"
(( png_count  > 0 )) && echo " - Converted PNG files:      $png_count ‚Üí $(human_size $png_size)"
(( webp_count > 0 )) && echo " - Converted WEBP files:     $webp_count ‚Üí $(human_size $webp_size)"

if (( total_input > 0 && webp_size > 0 )); then
  reduction=$(( (total_saved * 1000 / total_input + 5) / 10 ))
  echo " - Total Original Size:      $(human_size $total_input)"
  echo " - Total WEBP Size:          $(human_size $webp_size)"
  echo " - Size Savings:             $(human_size $total_saved) ($reduction% reduction)"
elif (( total_input > 0 )); then
  echo "‚ö†Ô∏è Conversion attempted but no WEBP files created."
else
  echo "‚ùå No files were converted."
fi
