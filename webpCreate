#!/usr/bin/env zsh
setopt null_glob

# ─── Help & Description ──────────────────────────────────────────────────────────
show_help() {
  cat <<-EOF
webpCreate: batch-convert images to WebP with concise progress and stats.

What it does:
  • Converts JPEG, PNG (case‐insensitive), and HEIC (via sips) to WebP  
  • Organizes originals into JPG/, PNG/, HEIC/ and outputs into WEBP/  
  • Handles name conflicts (overwrite/increment/skip)  
  • Optionally resizes longest side ≤ max dimension  
  • Supports quality tuning, lossless, multi‐thread, arbitrary cwebp flags, parallel dirs  
  • Reports per-directory file counts, sizes, total savings, and percentage reduction

Usage:
  webpCreate [options] [dir1 dir2 ...]
  If no directories are given, defaults to the current directory.

Installation & Updates:
  • Initial install:
      bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)  
  • For updates:
      update-webpCreate

Options:
  -h, --help            Show this help and exit
  -q, --quality Q       Set cwebp quality (0–100; default 80)
  --maxd N              Resize longest side to ≤ N px (skips prompt)
  --lossless            Use cwebp -lossless
  --mt, --multithread   Enable cwebp -mt (multi‐threaded)
  --cwoption OPT        Pass arbitrary OPT (e.g. "-af") to cwebp
  --parallel, -P        Process multiple directories in parallel

Examples:
  webpCreate .
  webpCreate -q 75 --maxd 1200 ~/Pictures ~/Downloads
  webpCreate --parallel --lossless --mt dirA dirB
EOF
}

# ─── Flag Parsing ───────────────────────────────────────────────────────────────
cwebp_opts=(-quiet)   # start with -quiet to suppress verbose output
do_parallel=false
dirs=()
quality=""
maxd_flag=""

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help) show_help; exit 0;;
    -q|--quality)       shift; quality=$1; cwebp_opts+=(-q $quality); shift;;
    --maxd)             shift; maxDim=$1; do_resize=true; maxd_flag="yes"; shift;;
    --lossless)         cwebp_opts+=(-lossless); shift;;
    --mt|--multithread) cwebp_opts+=(-mt); shift;;
    --cwoption)         shift; cwebp_opts+=("$1"); shift;;
    --parallel|-P)      do_parallel=true; shift;;
    --) shift; break;;
    -*) echo "Unknown option: $1"; exit 1;;
    *) dirs+=("$1"); shift;;
  esac
done

(( ${#dirs[@]} == 0 )) && dirs=(".")

# ─── Resize Prompt ─────────────────────────────────────────────────────────────
if [[ -z $maxd_flag ]]; then
  read -q "?Would you like to resize images so their longest side is capped? [y/N] " resize_choice
  echo
  if [[ $resize_choice =~ ^[Yy]$ ]]; then
    read -r "?Enter max dimension (pixels) for longest side (e.g. 1200): " maxDim
    [[ "$maxDim" =~ ^[0-9]+$ ]] || { echo "❌ Invalid number: $maxDim"; exit 1; }
    do_resize=true
  else
    do_resize=false
  fi
else
  do_resize=true
fi

# ─── Dependency Checks ──────────────────────────────────────────────────────────
for cmd in cwebp sips; do
  if ! command -v $cmd &>/dev/null; then
    brew_cmd=${cmd==cwebp?webp:imagemagick}
    echo "❌ Missing '$cmd'. Install with: brew install $brew_cmd"
    echo "   Or run installer: bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)"
    exit 1
  fi
done

# ─── Summary Data Containers ───────────────────────────────────────────────────
typeset -Ag SUM_JPG SUM_PNG SUM_WEBP SUM_COUNT
dirs_processed=()

# ─── Utilities ─────────────────────────────────────────────────────────────────
human_size(){
  local b=$1
  printf "%d.%02d MB" $((b/1024/1024)) $(((b/1024)%1024*100/1024))
}

ask_conflict(){
  local file=$1 choice
  while true; do
    echo "⚠️  WEBP/$file exists. (o)verwrite / (i)ncrement / (s)kip?"
    read -sk1 choice; echo
    case $choice in
      [oO]) return 0;;
      [iI]) return 1;;
      [sS]) return 2;;
      *) echo "❓ Press o, i, or s.";;
    esac
  done
}

convert_and_handle_conflict(){
  local input=$1 base out newW newH w h suffix
  base=${input%.*}
  suffix=$([ "$do_resize" = true ] && echo "-$maxDim" || echo "")
  out="${base}${suffix}.webp"

  # Determine resize params, if needed
  if $do_resize; then
    w=$(sips -g pixelWidth "$input"  | awk '/pixelWidth/  {print $2}')
    h=$(sips -g pixelHeight "$input" | awk '/pixelHeight/ {print $2}')
    if (( w >= h )); then newW=$maxDim; newH=0; else newW=0; newH=$maxDim; fi
  fi

  mkdir -p WEBP
  if [[ -e WEBP/$out ]]; then
    ask_conflict "$out"
    action=$?
    if (( action == 0 )); then
      : # overwrite
    elif (( action == 1 )); then
      local n=1
      while [[ -e WEBP/${base}${suffix}_$n.webp ]]; do ((n++)); done
      out="${base}${suffix}_$n.webp"
    else
      return 1
    fi
  fi

  # Run cwebp with -quiet; append resize flags if requested
  if $do_resize; then
    cwebp "${cwebp_opts[@]}" -resize $newW $newH "$input" -o "WEBP/$out"
  else
    cwebp "${cwebp_opts[@]}" "$input" -o "WEBP/$out"
  fi

  # Print concise per-file info: name, before→after sizes
  local in_size out_size
  in_size=$(stat -f%z "$input")
  out_size=$(stat -f%z "WEBP/$out")
  printf "▶ %s: %s → %s\n" \
    "$input" "$(human_size $in_size)" "$(human_size $out_size)"

  mv "$input" "$processed_dir"/
  return 0
}

# ─── Directory Processing Function ─────────────────────────────────────────────
process_directory(){
  local dir=$1 jpgs pngs heics ghost f size
  echo "── Processing: $dir ─────────────────────────────────────────"
  cd "$dir" || { echo "❌ Cannot cd into $dir"; return; }

  processed_dir=""  # will be set below

  # Ghost-file check
  ghosts=()
  for f in *.jpg(N) *.jpeg(N) *.png(N) *.JPG(N) *.JPEG(N) *.PNG(N); do
    [[ -e $f && ! -s $f ]] && ghosts+=("$f")
  done
  if (( ${#ghosts[@]} )); then
    echo "⚠️  ${#ghosts[@]} ghost files detected:"
    printf ' - %s\n' "${ghosts[@]}"
    read -q "?Proceed with downloaded files only? [y/N] " c; echo
    [[ $c != [yY] ]] && { echo "Skipping $dir"; cd - &>/dev/null; return; }
  fi

  # HEIC → JPEG
  heics=( *.heic(N) *.HEIC(N) )
  if (( ${#heics[@]} )); then
    mkdir -p HEIC
    for f in "${heics[@]}"; do
      sips -s format jpeg "$f" --out "${f%.*}.jpg"
      mv "$f" HEIC/
    done
  fi

  # Initialize counts & sums
  jpgs=( *.jpg(N) *.JPG(N) *.jpeg(N) *.JPEG(N) )
  pngs=( *.png(N) *.PNG(N) )
  SUM_JPG[$dir]=0; SUM_PNG[$dir]=0; SUM_WEBP[$dir]=0; SUM_COUNT[$dir]=0

  # Create processed directories
  mkdir -p JPG PNG
  processed_dir="JPG"

  # Convert JPG/JPEG
  for f in "${jpgs[@]}"; do
    [[ -f $f ]] || continue
    SUM_COUNT[$dir]=$(( SUM_COUNT[$dir] + 1 ))
    SUM_JPG[$dir]=$(( SUM_JPG[$dir] + $(stat -f%z "$f") ))
    if convert_and_handle_conflict "$f"; then
      mv "WEBP/${f%.*}${suffix}.webp" WEBP/
    fi
  done

  # Convert PNG
  processed_dir="PNG"
  for f in "${pngs[@]}"; do
    [[ -f $f ]] || continue
    SUM_COUNT[$dir]=$(( SUM_COUNT[$dir] + 1 ))
    SUM_PNG[$dir]=$(( SUM_PNG[$dir] + $(stat -f%z "$f") ))
    if convert_and_handle_conflict "$f"; then
      mv "WEBP/${f%.*}${suffix}.webp" WEBP/
    fi
  done

  # Tally WEBP sizes
  for w in WEBP/*.webp(N); do
    SUM_WEBP[$dir]=$(( SUM_WEBP[$dir] + $(stat -f%z "$w") ))
  done

  dirs_processed+=("$dir")
  cd - &>/dev/null
}

# ─── Prepare for Parallel Stats Collection ─────────────────────────────────────
if [[ $do_parallel = true ]]; then
  PARALLEL_TMPDIR=$(mktemp -d /tmp/webpCreate.XXXX)
  echo "🛠  Parallel mode: writing per-dir stats to $PARALLEL_TMPDIR"
fi

# ─── Main Loop: Parallel or Sequential ────────────────────────────────────────
if [[ $do_parallel = true ]]; then
  for d in "${dirs[@]}"; do
    process_directory "$d" >"$PARALLEL_TMPDIR/$(basename "$d").log" 2>&1 &
  done
  wait
else
  for d in "${dirs[@]}"; do
    process_directory "$d"
  done
fi

# ─── Final Summary ─────────────────────────────────────────────────────────────
echo; echo "# Final Conversion Summary"

if [[ -n $PARALLEL_TMPDIR ]]; then
  for stats in "$PARALLEL_TMPDIR"/*.log; do
    dir=$(basename "${stats%.log}")
    # Read the accumulated sums:
    orig=$(( SUM_JPG[$dir] + SUM_PNG[$dir] ))
    webp=${SUM_WEBP[$dir]}
    count=${SUM_COUNT[$dir]}
    saved=$(( orig - webp ))
    pct=$((( saved * 1000 / orig + 5 ) / 10 ))
    echo
    echo "• Directory: $dir"
    echo "   - Images processed:    $count"
    echo "   - Original total size: $(human_size $orig)"
    echo "   - WebP total size:     $(human_size $webp)"
    echo "   - Savings:             $(human_size $saved) ($pct% reduction)"
  done
  rm -rf "$PARALLEL_TMPDIR"
else
  for dir in "${dirs_processed[@]}"; do
    orig=$(( SUM_JPG[$dir] + SUM_PNG[$dir] ))
    webp=${SUM_WEBP[$dir]}
    count=${SUM_COUNT[$dir]}
    saved=$(( orig - webp ))
    pct=$((( saved * 1000 / orig + 5 ) / 10 ))
    echo
    echo "• Directory: $dir"
    echo "   - Images processed:    $count"
    echo "   - Original total size: $(human_size $orig)"
    echo "   - WebP total size:     $(human_size $webp)"
    echo "   - Savings:             $(human_size $saved) ($pct% reduction)"
  done
fi
