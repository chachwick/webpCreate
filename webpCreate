```zsh
#!/bin/zsh
setopt null_glob

echo "üõ†  Running webpCreate in: $(pwd)"

# ‚Äî Early Ghost File Detection (zero-byte Google Drive placeholders) ‚Äî
jpg_patterns=( *.jpg(N) *.JPG(N) *.jpeg(N) *.JPEG(N) )
png_patterns=( *.png(N) *.PNG(N) )
all_patterns=( "${jpg_patterns[@]}" "${png_patterns[@]}" )

ghosts=()
for f in "${all_patterns[@]}"; do
  # exists but zero‚Äêsize ‚Üí ghost
  [[ -e $f && ! -s $f ]] && ghosts+=("$f")
done

if (( ${#ghosts[@]} > 0 )); then
  echo "‚ö†Ô∏è  Detected ${#ghosts[@]} ghost (not downloaded) file(s):"
  printf ' - %s\n' "${ghosts[@]}"
  echo ""
  echo "What would you like to do?"
  echo "  [1] Continue with downloaded files only"
  echo "  [2] Quit and sync these files first (may use lots of drive space)"
  echo "  [3] Quit"
  echo -n "Enter choice [1/2/3]: "
  read choice
  case $choice in
    1) echo "‚úÖ Proceeding with available files only...";;
    2) echo "üëã Please download those files (e.g. open them in Finder), then re-run."; exit 0 ;;
    *) echo "üëã Exiting."; exit 0 ;;
  esac
fi

# ‚Äî Ask for maximum dimension ‚Äî
echo -n "Enter maximum dimension (in pixels) for the longest side, e.g. 1200: "
read maxDim
if ! [[ "$maxDim" =~ ^[0-9]+$ ]]; then
  echo "‚ùå Invalid number: $maxDim"; exit 1
fi
echo "‚ôªÔ∏è  Will resize images so their longest side is ${maxDim}px."

# ‚Äî Ensure cwebp is installed ‚Äî
if ! command -v cwebp &> /dev/null; then
  echo "‚ùå cwebp not found. Install with: brew install webp"
  exit 1
fi

# ‚Äî Initialize counters & accumulators ‚Äî
jpg_count=0; png_count=0; webp_count=0
jpg_size=0; png_size=0; webp_size=0

human_size() {
  local bytes=$1
  printf "%d.%02d MB" $((bytes/1024/1024)) $(((bytes/1024)%1024*100/1024))
}

ask_file_action() {
  local file="$1"
  while true; do
    echo "‚ö†Ô∏è  WEBP/$file exists. (o)verwrite / (i)ncrement / (s)kip?"
    read -sk1 choice; echo ""
    case $choice in
      [oO]) return 0 ;;
      [iI]) return 1 ;;
      [sS]) return 2 ;;
      *) echo "‚ùì Press o, i, or s." ;;
    esac
  done
}

convert_and_handle_conflict() {
  local input="$1"
  local base="${input%.*}"
  local suffix="$maxDim"
  local out="${base}-${suffix}.webp"

  # get original dimensions
  local w h newW newH
  w=$(sips -g pixelWidth  "$input" | awk '/pixelWidth/ {print $2}')
  h=$(sips -g pixelHeight "$input" | awk '/pixelHeight/ {print $2}')

  if (( w >= h )); then
    newW=$suffix; newH=0
  else
    newW=0; newH=$suffix
  fi

  mkdir -p WEBP

  if [[ -e "WEBP/$out" ]]; then
    ask_file_action "$out"
    action=$?
    if   [[ $action -eq 0 ]]; then
      cwebp -q 80 -resize $newW $newH "$input" -o "$out"
    elif [[ $action -eq 1 ]]; then
      local n=1
      while [[ -e "WEBP/${base}-${suffix}_$n.webp" ]]; do ((n++)); done
      out="${base}-${suffix}_$n.webp"
      cwebp -q 80 -resize $newW $newH "$input" -o "$out"
    else
      return 1
    fi
  else
    cwebp -q 80 -resize $newW $newH "$input" -o "$out"
  fi

  mv "$out" WEBP/ && return 0
  return 1
}

# ‚Äî Build lists of downloaded (non-ghost) files ‚Äî
jpg_files=()
for f in "${jpg_patterns[@]}"; do
  [[ -f $f && -s $f ]] && jpg_files+=("$f")
done

png_files=()
for f in "${png_patterns[@]}"; do
  [[ -f $f && -s $f ]] && png_files+=("$f")
done

# ‚Äî Convert JPG/JPEG variants ‚Äî
if (( ${#jpg_files[@]} > 0 )); then
  mkdir -p JPG
  for file in "${jpg_files[@]}"; do
    local size=$(stat -f%z "$file")
    echo "‚û°Ô∏è Converting $file"
    if convert_and_handle_conflict "$file"; then
      mv "$file" JPG/
      ((jpg_count++))
      ((jpg_size+=size))
    fi
  done
else
  echo "‚ö†Ô∏è No JPG/JPEG files to process."
fi

# ‚Äî Convert PNG variants ‚Äî
if (( ${#png_files[@]} > 0 )); then
  mkdir -p PNG
  for file in "${png_files[@]}"; do
    local size=$(stat -f%z "$file")
    echo "‚û°Ô∏è Converting $file"
    if convert_and_handle_conflict "$file"; then
      mv "$file" PNG/
      ((png_count++))
      ((png_size+=size))
    fi
  done
else
  echo "‚ö†Ô∏è No PNG files to process."
fi

# ‚Äî Tally WEBP outputs ‚Äî
webp_files=( WEBP/*.webp(N) )
for w in "${webp_files[@]}"; do
  ((webp_count++))
  webp_size=$((webp_size + $(stat -f%z "$w")))
done

# ‚Äî Final Summary ‚Äî
total_input=$((jpg_size + png_size))
total_saved=$((total_input - webp_size))

echo ""
echo "‚úÖ Conversion Summary:"
(( jpg_count  > 0 )) && echo " - Converted JPG/JPEG files: $jpg_count ‚Üí $(human_size $jpg_size)"
(( png_count  > 0 )) && echo " - Converted PNG files:      $png_count ‚Üí $(human_size $png_size)"
(( webp_count > 0 )) && echo " - Converted WEBP files:     $webp_count ‚Üí $(human_size $webp_size)"

if (( total_input > 0 && webp_size > 0 )); then
  reduction=$(( (total_saved * 1000 / total_input + 5) / 10 ))
  echo " - Total Original Size:      $(human_size $total_input)"
  echo " - Total WEBP Size:          $(human_size $webp_size)"
  echo " - Size Savings:             $(human_size $total_saved) ($reduction% reduction)"
elif (( total_input > 0 )); then
  echo "‚ö†Ô∏è Conversion attempted but no WEBP files created."
else
  echo "‚ùå No files were converted."
fi
```
