#!/usr/bin/env zsh
setopt null_glob

# â”€â”€â”€ Help & Description â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
show_help() {
  cat <<-EOF
webpCreate: batch-convert images to WebP with organization & stats.

What it does:
  â€¢ Converts .jpg/.jpeg/.png (case-insensitive) and HEIC â†’ JPEG (via sips)  
  â€¢ Organizes originals into JPG/, PNG/, HEIC/ and outputs into WEBP/  
  â€¢ Handles filename conflicts (overwrite/increment/skip)  
  â€¢ Optionally resizes so longest side â‰¤ max dimension  
  â€¢ Reports per-directory file counts & size savings

Why WebP?
  WebP delivers excellent compression for web imagesâ€”smaller files,
  faster pages, modern browser support. This script automates the
  end-to-end workflow and gives you clear savings data.

Usage:
  webpCreate [options] [dir1 dir2 ...]
  If no directories are given, defaults to the current directory.

Installation & Updates:
  â€¢ Initial install:  
      bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)  
  â€¢ For updates, run the companion command:  
      update-webpCreate  

Options:
  -h, --help            Show this help and exit
  --lossless            Use cwebpâ€™s -lossless mode
  --mt, --multithread   Enable intra-file multi-threading (-mt)
  --cwoption OPT        Pass OPT (e.g. "-af") to cwebp
  -q, --quality Q       Set cwebp quality to Q (e.g. 75)
  --maxd N              Resize longest side to at most N pixels (non-interactive)
  --parallel, -P        Process multiple directories in parallel

Examples:
  webpCreate .  
  webpCreate ~/Pics /tmp/foo /bar  
  webpCreate --parallel --lossless --mt ~/Downloads  
  webpCreate -q 90 --maxd 1200 ./images
EOF
}

# â”€â”€â”€ Flag Parsing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cwebp_opts=()
do_parallel=false
dirs=()
quality=""
maxd_flag=""

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help) show_help; exit 0;;
    --lossless)           cwebp_opts+=(-lossless); shift;;
    --mt|--multithread)   cwebp_opts+=(-mt);        shift;;
    --cwoption)           shift; cwebp_opts+=("$1"); shift;;
    -q|--quality)         shift; quality=$1; cwebp_opts+=(-q $quality); shift;;
    --maxd)               shift; maxDim=$1; do_resize=true; maxd_flag="yes"; shift;;
    --parallel|-P)        do_parallel=true;        shift;;
    --) shift; break;;
    -*) echo "Unknown option: $1"; exit 1;;
    *) dirs+=("$1"); shift;;
  esac
done

# Default to cwd if no dirs given
(( ${#dirs[@]} == 0 )) && dirs=(".")

# â”€â”€â”€ Resize Prompt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [[ -z $maxd_flag ]]; then
  read -q "?Would you like to resize images so their longest side is capped? [y/N] " resize_choice
  echo
  if [[ $resize_choice =~ ^[Yy]$ ]]; then
    read -r "?Enter max dimension (pixels) for longest side (e.g. 1200): " maxDim
    [[ "$maxDim" =~ ^[0-9]+$ ]] || { echo "âŒ Invalid number: $maxDim"; exit 1; }
    do_resize=true
  else
    do_resize=false
  fi
else
  # --maxd provided, skip prompt
  do_resize=true
fi

# â”€â”€â”€ Dependency Checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for cmd in cwebp sips; do
  if ! command -v $cmd &>/dev/null; then
    brew_cmd=${cmd==cwebp?webp:imagemagick}
    echo "âŒ Missing '$cmd'. Install with: brew install $brew_cmd"
    echo "   Or run installer: bash <(curl -fsSL https://raw.githubusercontent.com/chachwick/webpCreate/main/install-webpCreate.sh)"
    exit 1
  fi
done

# â”€â”€â”€ Summary Data Containers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
typeset -Ag SUM_JPG SUM_PNG SUM_WEBP
dirs_processed=()

# â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
human_size(){
  local b=$1
  printf "%d.%02d MB" $((b/1024/1024)) $(((b/1024)%1024*100/1024))
}

ask_conflict(){
  local file=$1 choice
  while true; do
    echo "âš ï¸  WEBP/$file exists. (o)verwrite / (i)ncrement / (s)kip?"
    read -sk1 choice; echo
    case $choice in
      [oO]) return 0;;
      [iI]) return 1;;
      [sS]) return 2;;
      *) echo "â“ Press o, i, or s.";;
    esac
  done
}

convert_and_handle_conflict(){
  local input=$1 base out newW newH w h suffix
  base=${input%.*}
  suffix=$([ "$do_resize" = true ] && echo "-$maxDim" || echo "")
  out="${base}${suffix}.webp"

  # Determine resize params
  if $do_resize; then
    w=$(sips -g pixelWidth "$input"  | awk '/pixelWidth/  {print $2}')
    h=$(sips -g pixelHeight "$input" | awk '/pixelHeight/ {print $2}')
    if (( w >= h )); then newW=$maxDim; newH=0; else newW=0; newH=$maxDim; fi
  fi

  mkdir -p WEBP
  if [[ -e WEBP/$out ]]; then
    ask_conflict "$out"; action=$?
    if   ((action==0)); then : # overwrite
    elif ((action==1)); then
      local n=1
      while [[ -e WEBP/${base}${suffix}_$n.webp ]]; do ((n++)); done
      out="${base}${suffix}_$n.webp"
    else
      return 1
    fi
  fi

  if $do_resize; then
    cwebp "${cwebp_opts[@]}" -resize $newW $newH "$input" -o "$out"
  else
    cwebp "${cwebp_opts[@]}" "$input" -o "$out"
  fi

  mv "$out" WEBP/ && return 0
  return 1
}

# â”€â”€â”€ Directory Processing Function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
process_directory(){
  local dir=$1 jpgs pngs heics ghost f size
  echo "â”€â”€ Processing: $dir â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  cd "$dir" || { echo "âŒ Cannot cd into $dir"; return; }

  # Ghost-file check
  ghosts=()
  for f in *.jpg(N) *.jpeg(N) *.png(N) *.JPG(N) *.JPEG(N) *.PNG(N); do
    [[ -e $f && ! -s $f ]] && ghosts+=("$f")
  done
  if (( ${#ghosts[@]} )); then
    echo "âš ï¸  ${#ghosts[@]} ghost files detected:"
    printf ' - %s\n' "${ghosts[@]}"
    read -q "?Proceed with downloaded files only? [y/N] " c; echo
    [[ $c != [yY] ]] && { echo "Skipping $dir"; cd - &>/dev/null; return; }
  fi

  # HEIC â†’ JPEG
  heics=( *.heic(N) *.HEIC(N) )
  if (( ${#heics[@]} )); then
    mkdir -p HEIC
    for f in "${heics[@]}"; do
      echo "â¡ï¸  Converting HEIC â†’ JPEG: $f"
      sips -s format jpeg "$f" --out "${f%.*}.jpg"
      mv "$f" HEIC/
    done
  fi

  # Gather lists & initialize sums
  jpgs=( *.jpg(N) *.JPG(N) *.jpeg(N) *.JPEG(N) )
  pngs=( *.png(N) *.PNG(N) )
  SUM_JPG[$dir]=0; SUM_PNG[$dir]=0; SUM_WEBP[$dir]=0

  # Convert JPG/JPEG
  if (( ${#jpgs[@]} )); then mkdir -p JPG; fi
  for f in "${jpgs[@]}"; do
    [[ -f $f ]] || continue
    size=$(stat -f%z "$f")
    echo "â¡ï¸ Converting $f"
    if convert_and_handle_conflict "$f"; then
      mv "$f" JPG/
      (( SUM_JPG[$dir]+=$size ))
    fi
  done

  # Convert PNG
  if (( ${#pngs[@]} )); then mkdir -p PNG; fi
  for f in "${pngs[@]}"; do
    [[ -f $f ]] || continue
    size=$(stat -f%z "$f")
    echo "â¡ï¸ Converting $f"
    if convert_and_handle_conflict "$f"; then
      mv "$f" PNG/
      (( SUM_PNG[$dir]+=$size ))
    fi
  done

  # Tally WEBP
  for w in WEBP/*.webp(N); do
    (( SUM_WEBP[$dir] += $(stat -f%z "$w") ))
  done

  dirs_processed+=("$dir")

  # â€¦ after tallying SUM_JPG, SUM_PNG, SUM_WEBP â€¦
  if [[ -n $PARALLEL_TMPDIR ]]; then
    orig=$(( SUM_JPG[$dir] + SUM_PNG[$dir] ))
    webp=${SUM_WEBP[$dir]}
    saved=$(( orig - webp ))
    pct=$((( saved * 1000 / orig + 5 ) / 10 ))
    echo "${dir}|${orig}|${webp}|${saved}|${pct}" > "$PARALLEL_TMPDIR/$(basename "$dir").stats"
  else
    dirs_processed+=("$dir")
  fi

  cd - &>/dev/null
}

#
# â”€â”€â”€ Prepare for Parallel Stats Collection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
if [[ $do_parallel = true ]]; then
  PARALLEL_TMPDIR=$(mktemp -d /tmp/webpCreate.XXXX)
  echo "ğŸ›   Parallel mode enabled; writing stats to $PARALLEL_TMPDIR"
fi

#
# â”€â”€â”€ Main Loop: Parallel or Sequential â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
if [[ $do_parallel = true ]]; then
  for d in "${dirs[@]}"; do
    process_directory "$d" &
  done
  wait
else
  for d in "${dirs[@]}"; do
    process_directory "$d"
  done
fi

#
# â”€â”€â”€ Final Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
if [[ -n $PARALLEL_TMPDIR ]]; then
  echo
  echo "# Final Conversion Summary"
  for stats in "$PARALLEL_TMPDIR"/*.stats; do
    IFS='|' read -r dir orig webp saved pct < "$stats"
    echo
    echo "â€¢ Directory: $dir"
    echo "   - Original size:  $(human_size $orig)"
    echo "   - WebP size:      $(human_size $webp)"
    echo "   - Savings:        $(human_size $saved) ($pct% reduction)"
  done
  rm -rf "$PARALLEL_TMPDIR"
else
  echo
  echo "# Final Conversion Summary"
  for dir in "${dirs_processed[@]}"; do
    orig=$(( SUM_JPG[$dir] + SUM_PNG[$dir] ))
    webp=${SUM_WEBP[$dir]}
    saved=$(( orig - webp ))
    pct=$((( saved * 1000 / orig + 5 ) / 10 ))
    echo
    echo "â€¢ Directory: $dir"
    echo "   - Original size:  $(human_size $orig)"
    echo "   - WebP size:      $(human_size $webp)"
    echo "   - Savings:        $(human_size $saved) ($pct% reduction)"
  done
fi
